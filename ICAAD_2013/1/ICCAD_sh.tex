
%% bare_conf.tex
%% V1.3
%% 2007/01/11
%% by Michael Shell
%% See:
%% http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.7 or later) with an IEEE conference paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/tex-archive/macros/latex/contrib/IEEEtran/
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE! 
%% User assumes all risk.
%% In no event shall IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%
%% File list of work: IEEEtran.cls, IEEEtran_HOWTO.pdf, bare_adv.tex,
%%                    bare_conf.tex, bare_jrnl.tex, bare_jrnl_compsoc.tex
%%*************************************************************************

% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. IEEE's font choices can trigger bugs that do  ***
% *** not appear when using other class files.                            ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/



% Note that the a4paper option is mainly intended so that authors in
% countries using A4 can easily print to A4 and see how their papers will
% look in print - the typesetting of the document will not typically be
% affected with changes in paper size (but the bottom and side margins will).
% Use the testflow package mentioned above to verify correct handling of
% both paper sizes by the user's LaTeX system.
%
% Also note that the "draftcls" or "draftclsnofoot", not "draft", option
% should be used if it is desired that the figures are to be displayed in
% draft mode.
%
\documentclass[conference]{IEEEtran}
% Add the compsoc option for Computer Society conferences.
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[conference]{../sty/IEEEtran}





% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/tex-archive/macros/latex/contrib/oberdiek/
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
%\usepackage{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 4.0 (2003-05-27) and later if using hyperref.sty. cite.sty does
% not currently provide for hyperlinked citations.
% The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/cite/
% The documentation is contained in the cite.sty file itself.






% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
  % \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at: 
% http://www.ctan.org/tex-archive/macros/latex/required/graphics/
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found as epslatex.ps or
% epslatex.pdf at: http://www.ctan.org/tex-archive/info/
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex





% *** MATH PACKAGES ***
%
%\usepackage[cmex10]{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics. If using
% it, be sure to load this package with the cmex10 option to ensure that
% only type 1 fonts will utilized at all point sizes. Without this option,
% it is possible that some math symbols, particularly those within
% footnotes, will be rendered in bitmap form which will result in a
% document that can not be IEEE Xplore compliant!
%
% Also, note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/





% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithms/
% There is also a support site at:
% http://algorithms.berlios.de/index.html
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithmicx/




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/


%\usepackage{mdwmath}
%\usepackage{mdwtab}
% Also highly recommended is Mark Wooding's extremely powerful MDW tools,
% especially mdwmath.sty and mdwtab.sty which are used to format equations
% and tables, respectively. The MDWtools set is already installed on most
% LaTeX systems. The lastest version and documentation is available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/mdwtools/


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.


%\usepackage{eqparbox}
% Also of notable interest is Scott Pakin's eqparbox package for creating
% (automatically sized) equal width boxes - aka "natural width parboxes".
% Available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/eqparbox/





% *** SUBFIGURE PACKAGES ***
%\usepackage[tight,footnotesize]{subfigure}
% subfigure.sty was written by Steven Douglas Cochran. This package makes it
% easy to put subfigures in your figures. e.g., "Figure 1a and 1b". For IEEE
% work, it is a good idea to load it with the tight package option to reduce
% the amount of white space around the subfigures. subfigure.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at:
% http://www.ctan.org/tex-archive/obsolete/macros/latex/contrib/subfigure/
% subfigure.sty has been superceeded by subfig.sty.



%\usepackage[caption=false]{caption}
%\usepackage[font=footnotesize]{subfig}
% subfig.sty, also written by Steven Douglas Cochran, is the modern
% replacement for subfigure.sty. However, subfig.sty requires and
% automatically loads Axel Sommerfeldt's caption.sty which will override
% IEEEtran.cls handling of captions and this will result in nonIEEE style
% figure/table captions. To prevent this problem, be sure and preload
% caption.sty with its "caption=false" package option. This is will preserve
% IEEEtran.cls handing of captions. Version 1.3 (2005/06/28) and later 
% (recommended due to many improvements over 1.2) of subfig.sty supports
% the caption=false option directly:
%\usepackage[caption=false,font=footnotesize]{subfig}
%
% The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/subfig/
% The latest version and documentation of caption.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/caption/




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure. The latest version and documentation can be found at:
% http://www.ctan.org/tex-archive/macros/latex/base/



%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/sttools/
% Documentation is contained in the stfloats.sty comments as well as in the
% presfull.pdf file. Do not use the stfloats baselinefloat ability as IEEE
% does not allow \baselineskip to stretch. Authors submitting work to the
% IEEE should note that IEEE rarely uses double column equations and
% that authors should try to avoid such use. Do not be tempted to use the
% cuted.sty or midfloat.sty packages (also by Sigitas Tolusis) as IEEE does
% not format its papers in such ways.





% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/misc/
% Read the url.sty source comments for usage information. Basically,
% \url{my_url_here}.





% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here

\usepackage{paralist}
\usepackage{comment}
\usepackage{amsthm}
\usepackage{amssymb,amsmath}
%\usepackage{natbib}
\usepackage{subfigure}
\usepackage{url}
\usepackage{graphicx}
\usepackage[ruled]{algorithm2e}
\usepackage{pslatex}

\newtheorem{clm}{Claim}

\makeatletter
\newsavebox\myboxA
\newsavebox\myboxB
\newlength\mylenA
\newcommand*\xoverline[2][0.75]{%
    \sbox{\myboxA}{$\m@th#2$}%
    \setbox\myboxB\null% Phantom box
    \ht\myboxB=\ht\myboxA%
    \dp\myboxB=\dp\myboxA%
    \wd\myboxB=#1\wd\myboxA% Scale phantom
    \sbox\myboxB{$\m@th\overline{\copy\myboxB}$}%  Overlined phantom
    \setlength\mylenA{\the\wd\myboxA}%   calc width diff
    \addtolength\mylenA{-\the\wd\myboxB}%
    \ifdim\wd\myboxB<\wd\myboxA%
       \rlap{\hskip 0.5\mylenA\usebox\myboxB}{\usebox\myboxA}%
    \else
        \hskip -0.5\mylenA\rlap{\usebox\myboxA}{\hskip 0.5\mylenA\usebox\myboxB}%
    \fi}
\makeatother

\begin{document}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{\huge{Using Checkpointing to Improve Time Bounds for STM Concurrency Control in Embedded Real-Time Software}}


% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\begin{comment}
\author{\IEEEauthorblockN{Mohammed Elshambakey}
\IEEEauthorblockA{ECE, VT\\
Blacksburg, VA 24060\\
Email: shambake@vt.edu}
\and
\IEEEauthorblockN{Binoy Ravindran}
\IEEEauthorblockA{ECE, VT\\
Blacksburg, VA 24060\\
Email: binoy@vt.edu}
}
\end{comment}

\author{\IEEEauthorblockN{}
\IEEEauthorblockA{}
}
% conference papers do not typically use \thanks and this command
% is locked out in conference mode. If really needed, such as for
% the acknowledgment of grants, issue a \IEEEoverridecommandlockouts
% after \documentclass

% for over three affiliations, or if they all won't fit within the width
% of the page, use this alternative format:
% 
%\author{\IEEEauthorblockN{Michael Shell\IEEEauthorrefmark{1},
%Homer Simpson\IEEEauthorrefmark{2},
%James Kirk\IEEEauthorrefmark{3}, 
%Montgomery Scott\IEEEauthorrefmark{3} and
%Eldon Tyrell\IEEEauthorrefmark{4}}
%\IEEEauthorblockA{\IEEEauthorrefmark{1}School of Electrical and Computer Engineering\\
%Georgia Institute of Technology,
%Atlanta, Georgia 30332--0250\\ Email: see http://www.michaelshell.org/contact.html}
%\IEEEauthorblockA{\IEEEauthorrefmark{2}Twentieth Century Fox, Springfield, USA\\
%Email: homer@thesimpsons.com}
%\IEEEauthorblockA{\IEEEauthorrefmark{3}Starfleet Academy, San Francisco, California 96678-2391\\
%Telephone: (800) 555--1212, Fax: (888) 555--1212}
%\IEEEauthorblockA{\IEEEauthorrefmark{4}Tyrell Inc., 123 Replicant Street, Los Angeles, California 90210--4321}}




% use for special paper notices
%\IEEEspecialpapernotice{(Invited Paper)}




% make the title area
\maketitle


\begin{abstract}
%\boldmath
We consider checkpointing with software transactional memory (STM) concurrency control for embedded multicore real-time software, and present a modified version of FBLT contention manager called \textit{Checkpointing FBLT} (CPFBLT). We upper bound transactional retries and task response times under CPFBLT, and identify when CPFBLT is a more appropriate alternative to FBLT without checkpointing.
\end{abstract}
% IEEEtran.cls defaults to using nonbold math in the Abstract.
% This preserves the distinction between vectors and scalars. However,
% if the conference you are submitting to favors bold math in the abstract,
% then you can use LaTeX's standard command \boldmath at the very start
% of the abstract to achieve this. Many IEEE journals/conferences frown on
% math in the abstract anyway.

% no keywords




% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle



\section{Introduction}

\label{sec:intro}
%
Embedded systems sense physical processes and control their behavior, typically through feedback loops. Since physical processes are concurrent, computations that control them must also be concurrent, enabling them to process multiple streams of sensor input and control multiple actuators, all concurrently while satisfying time constraints. 
%Often, such computations need to concurrently read/write shared data objects. They must also process sensor input and react, while satisfying time constraints. 

The de facto standard for concurrent programming is the threads abstraction, and the 
de facto synchronization abstraction is locks. Lock-based concurrency control has significant programmability, scalability, and composability challenges~\cite{Herlihy:2006:AMP:1146381.1146382}.
 Transactional memory (TM) is an alternative synchronization model for shared memory objects that promises to alleviate these difficulties. With TM, code that read/write shared objects is organized as \textit{memory transactions}, which execute speculatively, while logging changes made to objects. Two transactions conflict if they access the same object and at least one access is a write. When that happens, a contention manager (CM)~\cite{Guerraoui:2005:TTT:1073814.1073863} resolves the conflict by aborting one and allowing the other to commit, yielding (the illusion of) atomicity. Aborted transactions are re-started, after rolling back the changes. In addition to a simple programming model, TM provides performance comparable to lock-free approach, especially for high contention and read-dominated workloads (see an example TM system's performance in~\cite{Saha:2006:MHP:1122971.1123001}), and is composable~\cite{Harris:2005:CMT:1065944.1065952}. TM has been proposed in hardware, called HTM, and in software, called STM, with the usual tradeoffs: HTM has lesser overhead, but needs transactional support in hardware; STM is available on any hardware. Given STM's programmability, scalability, and composability advantages, it is a compelling concurrency control technique also for multicore embedded real-time software. However, this requires  bounding transactional  retries, as real-time threads which subsume transactions, must satisfy time constraints.  Retry bounds under STM are dependent on the CM policy at hand. 

Past real-time CM research proposed resolving transactional contention using dynamic and fixed priorities of parent threads. \cite{6045438,stmconcurrencycontrol:emsoft11,lcmdac2012} present  Earliest Deadline CM (ECM) and Rate Monotonic CM (RCM)~, which are used with global EDF (G-EDF) and global RMS (G-RMS) multicore real-time schedulers \cite{Davis:2011:SHR:1978802.1978814}.
In particular,~\cite{stmconcurrencycontrol:emsoft11} shows that ECM and RCM achieve higher schedulability -- i.e., greater number of task sets meeting their time constraints -- than lock-free synchronization only under some ranges for the maximum atomic section length. That range is significantly expanded with the Length-based CM (LCM) in~\cite{lcmdac2012}, increasing the coverage of STM's timeliness superiority. ECM, RCM, and LCM suffer from transitive retry. Transitive retry means one transaction aborts and retries due to another transaction with no shared objects between both transactions. Transitive retry is introduced due to access of multiple objects per transaction. Thus, ECM, RCM and LCM cannot handle multiple objects per transaction efficiently. These limitations are overcome with the Priority with Negative value and First access CM (PNF)~\cite{pnf_dac_asp}. However, PNF requires prior knowledge of all objects accessed by each transaction. This significantly limits programmability, and is incompatible with dynamic STM implementations~\cite{Herlihy:2003:STM:872035.872048}. Additionally, PNF is a centralized CM, which increases overheads and retry costs, and has a complex implementation. First Bounded, Last Timestamp CM (or FBLT)~\cite{fblt}, in contrast to PNF, does not require prior knowledge of objects accessed by transactions. Moreover, FBLT allows each transaction to access multiple objects with shorter transitive retry cost than ECM, RCM and LCM. Retry cost under FBLT is close or better than retry cost under PNF. This results from prior knowledge of accessed objects per transaction under PNF. Additionally, FBLT is a decentralized CM that has a simpler implementation than PNF.

%SH_ST
Under previous CMs, if two transactions conflict on a specific object, the aborted transaction must restart from the beginning. Even if the contended object is not initially accessed at the beginning of the aborted transaction. Thus, the time between the beginning of the aborted transaction and first access to the contended object is wasted. During this wasted time, other transactions may also conflict with the aborted transaction. Thus, increasing chances to abort it again. Checkpointing~\cite{Koskinen:2008:CCI:1378533.1378563} can be used to solve this problem. checkpointing can reduce response time of threads with conflicting transactions. Under checkpointing, a transaction retreats to a previous control flow location upon conflict. So, an aborted transaction does not have to retreat to its beginning.

As FBLT is shown to be better or equal to ECM, RCM, LCM and PNF~\cite{fblt}, we investigate effect of checkpointing to FBLT. We present the motivation for introducing checkpointing into FBLT in Section~\ref{sec:motivation}. We introduce checkpointing FBLT (CPFBLT) that combines original FBLT with checkpointing (Section~\ref{sec:cpfblt_design}). We establish CPFBLT's retry and response time upper bounds under G-EDF and G-RMA schedulers (Section~\ref{sec:cpfblt rc}). We also identify the conditions under which CPFBLT is a better alternative to non-checkpointing FBLT (Section~\ref{sec:schedulabiltiy comparison}). We implement FBLT and CPFBLT in the Rochester STM framework~\cite{marathe2006lowering} and conduct experimental studies (Section~\ref{exp_eval}). Our results reveal that CPFBLT has shorter response time than non-checkpointing FBLT.

Thus, the paper's contribution is the use of checkpointing as a complementary tool to FBLT to further enhance response time. CPFBLT, thus allows programmers to reap STM's significant programmability and composability benefits for multicore embedded real-time software.
%SH_END

\section{Related Work}
\label{sec:past}

Transactional-like concurrency control without using locks, for real-time systems, has been previously studied in the context of non-blocking data structures (e.g.,~\cite{anderson95realtime}). Despite their advantages over locks 
(e.g., deadlock-freedom), their programmability has remained a challenge. Past studies show that they are best suited for simple data structures where their retry cost is competitive to the cost of lock-based synchronization~\cite{bc+08}.  In contrast, STM is semantically simpler~\cite{Herlihy:2006:AMP:1146381.1146382}, and is often the only viable lock-free solution for complex data structures (e.g., red/black tree)~\cite{key-1} and nested critical sections~\cite{Saha:2006:MHP:1122971.1123001}. STM concurrency control for real-time systems has been previously studied in~\cite{manson2006preemptible,fahmy2009bounding,sarni2009real,schoeberl2010rttm,key-1,barrosmanaging,stmconcurrencycontrol:emsoft11,lcmdac2012,pnf_dac_asp,fblt}.

\cite{manson2006preemptible} proposes a restricted version of STM for uniprocessors. \cite{fahmy2009bounding} bounds response times in distributed  systems with STM synchronization. \cite{fahmy2009bounding} considers Pfair scheduling, limit to small atomic regions with fixed size, and limit transaction execution to span at most two quanta. \cite{sarni2009real} presents real-time scheduling of transactions and serializes transactions based on deadlines. However, the work does not bound retries and response times. \cite{schoeberl2010rttm} proposes real-time HTM. \cite{schoeberl2010rttm} assumes that the worst case conflict between atomic sections of different tasks occurs when the sections are released at the same time. 

\cite{key-1} upper bounds retries and response times for ECM with G-EDF, and identify the tradeoffs with locking and lock-free protocols. Similar to~\cite{schoeberl2010rttm},~\cite{key-1} also assumes that the worst case conflict between atomic sections occurs when the sections are released simultaneously. The ideas in~\cite{key-1} are extended in~\cite{barrosmanaging}, which presents three real-time CM designs.
 
\cite{stmconcurrencycontrol:emsoft11} presents the ECM and RCM contention managers, and upper bounds transactional retries and task response times under them.~\cite{stmconcurrencycontrol:emsoft11} also identifies the conditions under which ECM and RCM are superior to lock-free techniques. In particular, \cite{stmconcurrencycontrol:emsoft11} shows that, STM's superiority holds only under some ranges for the maximum atomic section length.  Moreover,~\cite{stmconcurrencycontrol:emsoft11} restricts transactions to access only one object.

\cite{lcmdac2012} presents the LCM contention manager, and upper bounds transactional retry cost and task response times for G-EDF and G-RMA schedulers. This work also compares (analytically and experimentally) LCM with ECM, RCM, and lock-free synchronization. However, similar to~
\cite{lcmdac2012},~\cite{stmconcurrencycontrol:emsoft11} restricts transactions to access only one object. 

\cite{pnf_dac_asp} presents the PNF contention manager, which allows transactions to access  multiple objects and avoids the consequent transitive retry effect. The work also upper bounds transactional retries and task response times under G-EDF and G-RMA. However, PNF requires a-priori knowledge of the objects accessed by each transaction, which is not always possible, limits programmability, and is incompatible with dynamic STM implementations~\cite{Herlihy:2003:STM:872035.872048}. Additionally, PNF is a centralized CM with complex implementation.

\cite{fblt} presents the FBLT contention manager. In contrast to PNF, FBLT does not require prior knowledge of required objects by each transaction. FBLT premits multiple objects per transaction.
Under FBLT, each transaction can be aborted for a specific number of times. Afterwards, the transaction becomes non-preemptive. Non-preemptive transaction cannot be aborted except by another non-preemptive transaction. Non-preemptive transactions resolve conflicts based on the time they became non-preemptive. 

%SH_ST
Previous CMs try to enhance response time of real-time tasks using different policies for conflict resolution. Checkpointing does not require aborted transaction to restart from beginning. Thus, Checkpointing can be plugged into different CMs to further improve response time. \cite{Koskinen:2008:CCI:1378533.1378563} introduces checkpointing as an alternative to closed nesting transactions\cite{turcu2012closed}. \cite{Koskinen:2008:CCI:1378533.1378563} uses boosted transactions \cite{Herlihy:2008:TBM:1345206.1345237} instead of closed nesting \cite{Peri:2011:CCE:1946143.1946152,turcu2012closed,6267834} to implement checkpointing. Booseted transactions are based on linearizable objects with abstract states and concrete implementation. Methods under boosted transaction have well defined semantics to transit objects from one state to another. Inverse methods are used to restore objects to previous states. Upon a conflict, a transaction does not need to revert to its beginning, but rather to a point where the conflict can be avoided. Thus, checkpointing enables partial abort. \cite{turcu_phd_proposal} applies checkpointing in distributed transactional memory using Hyflow \cite{Saad:2011:HHP:1996130.1996167}.
%SH_END
%
\section{Preliminary}

We consider a multiprocessor system with $m$ identical processors and $n$ sporadic tasks $\tau_1, \tau_2,\ldots, \tau_n$. The $k^{th}$ instance (or job) of a task $\tau_i$ is denoted $\tau_i^k$. Each task $\tau_i$ is specified by its worst case execution time (WCET) $c_i$, its minimum period $T_i$ between any two consecutive instances, and its relative deadline $D_i$, where $D_i=T_i$. Job $\tau_i^j$ is released at time $r_i^j$ and must finish no later than its absolute deadline $d_i^j=r_i^j+D_i$. Under a fixed priority scheduler such as G-RMA, $p_i$ determines $\tau_i$'s (fixed) priority and it is constant for all instances of $\tau_i$. Under a dynamic priority scheduler such as G-EDF, a job $\tau_i^j$'s priority, $p_i^j$, differs from one instance to another. 
%A task $\tau_j$ may interfere with task $\tau_i$ for a number of times during an interval $L$, and this number is denoted as $G_{ij}(L)$. 

\textit{Shared objects.}
 A task may need to read/write shared, in-memory data objects while it is executing any of its atomic sections (transactions), which are synchronized using STM. 
%The set of atomic sections of task $\tau_i$ is denoted $s_i$. 
$s_i^k$ is the $k^{th}$ atomic section of $\tau_i$. Each object, $\theta$, can be accessed by multiple tasks. The set of distinct objects accessed by $s_i^k$ is $\Theta_i^k$. 
%The set of atomic sections used by $\tau_i$ to access $\theta$ is $s_i(\theta)$, and the sum of the lengths of those atomic sections is $len(s_i(\theta))$. $s_i^k(\theta)$ is the $k^{th}$ atomic section of $\tau_i$ that accesses $\theta$. $s_i^k$ can access one or more objects in $\Theta_i$. So, $s_i^k$ refers to the transaction itself, regardless of the objects accessed by the transaction. We denote the set of all accessed objects by $s_i^k$ as $\Theta_i^k$. While $s_i^k(\theta)$ implies that $s_i^k$ accesses an object $\theta \in \Theta_i^k$, $s_i^k(\Theta)$ implies that $s_i^k$ accesses a set of objects $\Theta=\{\theta \in \Theta_i^k$ \}. $\bar{s_i^k}=\bar{s_i^k}(\Theta)$ refers only once to $s_i^k$, regardless of the number of objects in $\Theta$. So, $|\bar{s_i^k}(\Theta)|_{\forall \theta \in \Theta}=1$.
 %
$s_i^k$ executes for a duration $len(s_i^k)$. Let $s_i^k$ accesses objects $\theta 1,\theta 2, ... ,\theta g, ... ,\theta z$ in that order. If all objects before $\theta g$ are not shared between $s_i^k$ and any other transaction, then $\nabla_{i*}^k$ is the time interval between start of $s_i^k$ and the first access to $\theta g$ by $s_i^k$. So, $\nabla_{i*}^k$ is the time interval between start of $s_i^k$ and the first access to any shared object between $s_i^k$ and any other transaction. $rt\left(\nabla_{i*}^k\right)=\frac{\nabla_{i*}^k}{len(s_i^k)}$ is the maximum ratio of length of $s_i^k$ where objects can be shared between $s_i^k$ and other transactions. $\xoverline[0.75]{rt \left(\nabla_{i*}^k\right)}=1-rt\left(\nabla_{i*}^k\right)$ is the minimum ratio of length of $s_i^k$ where no objects can be shared between $s_i^k$ and other transactions. $\xoverline[0.75]{rt\left(\nabla\right)}=max\left(\xoverline[0.75]{rt\left(\nabla_{i*}^k\right)}\right),\,\forall s_i^k$ is the maximum $\xoverline[0.75]{rt\left(\nabla_{i*}^k\right)}$ between all transactions.
%$len(s_i^k)=len(s_i^k(\theta))=len(s_i^k(\Theta))=len(s_i^k(\Theta_i^k))$ The set of tasks sharing $\theta$ with $\tau_i$ is denoted $\gamma_i(\theta)$. 
%
%The maximum-length atomic section in $\tau_i$ that accesses $\theta$ is denoted $s_{i_{max}} (\theta)$, while the maximum one among all tasks is $s_{max} (\theta)$, and the maximum one among tasks with priorities lower than that of $\tau_i$ is $s_{max}^i (\theta)$. $s_{max}^i(\Theta_h^i)=max\{s_{max}^i(\theta):\forall \theta \in \Theta_h^i\}$.

\textit{STM retry cost.} If two or more atomic sections conflict, the CM will commit one section and abort and retry the others, increasing the time to execute the aborted transactions. 
%The increased time that an atomic section $s_i^p (\theta)$ will take to execute due to a conflict with another section $s_j^k (\theta)$, is denoted $W_{i}^{p}(s_{j}^{k}(\theta))$.
 If an atomic section, $s_i^p$, is already executing, and another atomic section $s_j^k$ tries to access a shared object with $s_i^p$, then $s_j^k$ is said to ``interfere" or ``conflict" with $s_i^p$. The job $s_j^k$ is the ``interfering job", and the job $s_i^p$ is the ``interfered job". The total time that a task $\tau_i$'s atomic sections have to retry over $T_i$ is denoted $RC(T_i)$.
% 

Due to \textit{transitive retry}~\cite{pnf_dac_asp,fblt}, an atomic section $s_i^k$ may retry due to another atomic section $s_j^l$, where $s_i^k$ and $s_j^l$ have no shared objects. Transitive retry happens when $s_j^l$ conflicts with another transaction $s_h^u$, and $s_h^u$ conflicts with $s_i^k$. $s_i^k$ is said to transitively, or indirectly, retry due to $s_j^l$.
%$\Theta_i^*$ denotes the set of objects not accessed directly by atomic sections in $\tau_i$, but can cause transactions in $\tau_i$ to retry due to transitive retry. $\Theta_i^{ex}(=\Theta_i + \Theta_i^*)$ is the set of all objects that can cause transactions in $\tau_i$ to retry directly or through transitive retry. $\Theta_i^{k^{ex}}$ is the subset of objects in $\Theta_i^{ex}$ that can cause direct or transitive conflict to $s_i^k$. $\gamma_i^*$ is the set of tasks that accesses  objects in $\Theta_i^*$. $\gamma_i^{ex}(=\gamma_i + \gamma_i^*)$ is the set of all tasks that can directly or indirectly (through transitive retry) cause transactions in $\tau_i$ to abort and retry. $\gamma_i^k$ is the set of tasks that can directly cause $s_i^k$ to abort and retry. $\gamma_i^{k^{ex}}$ is the set of tasks that can directly or indirectly (through transitive retry) cause $s_i^k$ to abort and retry.
%  
%The additional amount of time by which all interfering jobs of $\tau_j$ increases the response time of any job of $\tau_i$ during $L$, without considering retries due to atomic sections, is denoted $W_{ij}(L)$.

%SH_ST
\section{Motivation}\label{sec:motivation}

Under checkpointing, a transaction $s_i^k \in \tau_i$ does not need to restart from the beginning upon a conflict on object $\theta$. $s_i^k$ just needs to return to the first point it accessed $\theta$. If $s_i^k$ needs to restart from its beginning, then the time between the beginning of $s_i^k$ and the first access to $\theta$ is wasted. Besides, restarting $s_i^k$ from its beginning increases the chances of aborting $s_i^k$ by other transactions. Thus, response time of $\tau_i$ can be improved by checkpointing unless $s_i^k$ acquires all its objects at its beginning. While ECM, RCM, LCM, PNF and FBLT without checkpointing try to resolve conflicts using proper strategies, checkpointing enhances performance by reducing aborted part of each transaction. Thus, checkpointing acts as a complementary component to different CMs to further enhance response time.

Behaviour of some CMs, like PNF~\cite{pnf_dac_asp}, can make checkpointing useless. PNF requires a priori knowledge of accessed objects within transactions. Only the first $m$ non-conflicting transactions are allowed to execute concurrently and non-preemptively. Thus, PNF makes no use of checkpointing because there is no conflict between non-preemptive transactions.

Other CMs (e. g., FBLT\cite{fblt}) allow conflicting transaction to run concurrently. So, FBLT can benefit from checkpointing. FBLT, by definition, depends on LCM. LCM, in turn, depends
on ECM for G-EDF and RCM for G-RMA. Experimental results show superiority of FBLT over LCM, ECM and RCM\cite{fblt}. Due to prior knowledge of accessed objects per transaction in PNF, retry cost under FBLT is close or better than retry cost under PNF~\cite{fblt}. So, we extend FBLT to checpointing FBLT (CPFBLT) to improve response time than the non-checkpointing FBLT (NCPFBLT).

\section{Checkpointing FBLT (CPFBLT)}\label{sec:cpfblt_design}

CPFBLT depends on LCM~\cite{lcmdac2012} with checkpointing. So, we initially illustrate LCM integrated with checkpointing (Section~\ref{sec:cplcm}). Afterwards, we illustrate FBLT with checkpointing in (Section~\ref{sec:design_cpfblt}).

\subsection{Checkpointing LCM (CPLCM)}\label{sec:cplcm}

Algorithm~\ref{alg:cplcm} presents LCM~\cite{lcmdac2012} integrated with checkpointing to give CPLCM. 
%
\begin{algorithm}[!htpd]
\footnotesize{
\LinesNumbered
\KwData{\\
$s_{i}^k\rightarrow$ interfered transaction.\\
$s_{j}^l\rightarrow$ interfering transaction with $s_i^k$ on object $\theta_{ij}^{kl}$.\\
$\psi\rightarrow$ user predefined threshold $\in [0,1]$.\\
$\epsilon_i^k\rightarrow$ remaining execution length of $s_i^k$ when interfered by $s_j^l$.\\
$cp_h^u(\theta) \rightarrow$ recorded checkpoint in transaction $s_h^u$ for newly accessed object $\theta$}
\KwResult{which transaction of $s_{i}^k$ or $s_{j}^l$ aborts}
\ForEach{newly accessed $\theta$ requested by any transaction $s_h^u$}{Add a checkpoint $cp_h^u(\theta)$\label{cplcm_step_add_new_cp}}
\eIf{$p_i^k > p_j^l$}
	{$s_{j}^l$ aborts and retreats to $cp_j^l(\theta_{ij}^{kl})$\label{cp-step_sicommits}\;
	Remove all checkpoints in $s_j^l$ recorded after $cp_j^l(\theta_{ij}^{kl})$\label{cp_step_rem_cp_jl_1}}
	{$c_{ij}^{kl}=len(s_j^l)/len(s_i^k)$\label{cp-step_cijkl}\;
	$\alpha_{ij}^{kl}=ln(\psi)/(ln(\psi)-c_{ij}^{kl})$\label{cp-step_alphaijkl}\;
	$\alpha_i^k=\left(len(s_i^k)-\epsilon_i^k\right)/len(s_i^k)$\label{cp_step_alpha}\;
	\eIf{$\alpha_i^k \le \alpha_{ij}^{kl}$}
	{$s_{i}^k$ aborts and retreats to $cp_i^k(\theta_{ij}^{kl})$\label{cp-step_siaborts}\;
	Remove all checkpoints in $s_i^k$ recorded after $cp_i^k(\theta_{ij}^{kl})$\label{cp_step_rem_cp_ik}}
	{$s_{j}^l$ aborts and retreats to $cp_j^l(\theta_{ij}^{kl})$\label{cp-step_sjaborts}\;
	Remove all checkpoints in $s_j^l$ recorded after $cp_j^l(\theta_{ij}^{kl})$\label{cp_step_rem_cp_jl_2}}
	}
	}
\caption{CPLCM}
\label{alg:cplcm}
\end{algorithm}
%
A new checkpoint is recorded for each newly accessed object $\theta$ by any transaction $s_h^u$ (step~\ref{cplcm_step_add_new_cp}). Checkpoint is recorded when $\theta$ is accessed for the first time because any further changes to $\theta$ will be discarded upon conflict. CPLCM uses priorities of $s_i^k$ and $s_j^l$, the remaining length of $s_{i}^{k}$ when it is interfered, as well as $len(s_{j}^{l})$, to decide which transaction must be aborted. If $p_i^k > p_j^l$, then $s_{j}^l$ would be the transaction to abort because of lower priority of $s_j
^l$, and the start of $s_{i}^k$ before $s_j^l$ (step~\ref{cp-step_sicommits}). Otherwise, $c_{ij}^{kl}$, $\alpha_{ij}^{kl}$ and $\alpha$ are calculated (steps~\ref{cp-step_cijkl},~\ref{cp-step_alphaijkl} and~\ref{cp_step_alpha}) to determine whether it is worth aborting $s_{i}^k$ in favour of $s_{j}^l$. If $len(s_j^l)$ is relatively small compared to $len(s_i^k)$, then $c_{ij}^{kl}$ approaches its minimum value (i.e., 0), and $\alpha_{ij}^{kl}$ approaches its maximum value (i.e., 1) (steps~\ref{cp-step_cijkl},~\ref{cp-step_alphaijkl}). Otherwise, $c_{ij}^{kl}$ approaches its maximum value (i.e., $\infty$), and $\alpha_{ij}^{kl}$ approaches its minimum value (i.e., 0). $\Psi$ is a predefined threshold that lies in $[0,1]$ as defined in~\cite{lcmdac2012}. The remaining execution length of $s_i^k$ (i.e., $\epsilon_i^k$) is used to calculate $\alpha_i^k$ (step~\ref{cp_step_alpha}). If $s_i^k$ still has much work to do, then $\epsilon_i^k$ approaches $len(s_i^k)$ and $\alpha_i^k$ approaches 0. Otherwise, $\alpha_i^k$ approaches 1. If $len(s_i^k)$ is much longer than $len(s_j^l)$, or $s_i^k$ still has much work to do when interfered by $s_j^l$, then $\alpha_i^k$ tends to be smaller than $\alpha_{ij}^{kl}$. Consequently, $s_i^k$ aborts in favour of $s_j^l$. When $s_i^k$ aborts upon a conflict with $s_j^l$ on object $\theta_{ij}^{kl}$, then checkpoints in $s_i^k$ recorded after $cp_i^k(\theta_{ij}^{kl})$ are removed (step~\ref{cp_step_rem_cp_ik}). Prior checkpoints to $cp_i^k(\theta_{ij}^{kl})$ remain the same. Also, if $s_j^l$ aborts in favour of $s_i^k$, then all checkpoints in $s_j^l$ recorded after $cp_j^l(\theta_{ij}^{kl})$ are removed (steps~\ref{cp_step_rem_cp_jl_1},~\ref{cp_step_rem_cp_jl_2}).

\subsection{Design of CPFBLT}\label{sec:design_cpfblt}

Algorithm~\ref{cpfblt-algorithm} illustrates FBLT~\cite{fblt} integrated with checkpointing to give CPFBLT. 
%
\begin{algorithm}[!htpd]
\footnotesize{
\LinesNumbered
\KwData{\\
$s_{i}^k$: interfered transaction.\\
$s_{j}^l$: interfering transaction.\\
$\delta_i^k$: maximum number of times $s_i^k$ can be aborted during $T_i$.\\
$\eta_i^k$: number of times $s_i^k$ has already been aborted up to now.\\
$m\_$set: contains at most $m$ non-preemptive transactions. $m$ is number of processors.\\
$m\_prio$: priority of any transaction in $m\_$set. $m\_prio$ is higher than any priority of any real-time task.\\
$r(s_i^k)$: time point at which $s_i^k$ joined $m\_$set.\\
$cp_h^u(\theta) \rightarrow$ recorded checkpoint in transaction $s_h^u$ for newly accessed object $\theta$
}
\KwResult{which transaction, $s_i^k$ or $s_j^l$, aborts}
\ForEach{newly accessed $\theta$ requested by any transaction $s_h^u$}{Add a checkpoint $cp_h^u(\theta)$\label{cpfblt_step_add_new_cp}}
\uIf{\label{cpfblt-both preemptive}$s_i^k,\, s_j^l \not\in m\_set$}
{
%
Apply CPLCM (Algorithm~\ref{alg:cplcm})\label{apply cplcm}\;
%
\eIf{\label{cpfblt-preemptive s_i^k aborted}$s_{i}^k$ is aborted}
{
\eIf{$\eta_i^k<\delta_i^k$}
{
Increment $\eta_i^k$ by 1\label{cpfblt-increment eta 1}\;
}
{
Add $s_i^k$ to $m\_$set\label{cpfblt-add to m_set 1}\;
Record $r(s_i^k)$\label{cpfblt-record 1}\;
Increase priority of $s_i^k$ to $m\_prio$\label{cpfblt-increase priority 1}\;
}
}
{
Swap $s_{i}^k$ and $s_{j}^l$\;
Go to Step~\ref{cpfblt-preemptive s_i^k aborted}\;
}
}
\uElseIf{\label{cpfblt-s_j^l is non preemptive}$s_j^l \in m\_set, s_i^k \not\in m\_set$}
{
$s_{i}^k$ aborts and retreats to $cp_i^k(\theta_{ij}^{kl})$\;
Remove all checkpoints in $s_i^k$ recorded after $cp_i^k(\theta_{ij}^{kl})$\label{cpfblt_step_rem_cp_ik_1}\;
\eIf{$\eta_i^k < \delta_i^k$}
{
Increment $\eta_i^k$ by 1\label{cpfblt-increment eta 2}\;
}
{
Add $s_i^k$ to $m\_$set\label{cpfblt-add to m_set 2}\;
Record $r(s_i^k)$\label{cpfblt-record 2}\;
Increase priority of $s_i^k$ to $m\_prio$\label{cpfblt-increase priority 2}\;
}
}
\uElseIf{\label{cpfblt-s_i^k is non-preemptive}$s_i^k \in m\_set, s_j^l \not\in m\_set$}
{
Swap $s_{i}^k$ and $s_{j}^l$\;
Go to Step~\ref{cpfblt-s_j^l is non preemptive}\label{cpfblt-end preemptive and non preemptive}\;
}
\Else
{
\label{cpfblt-both non preemptive}
\eIf{$r(s_i^k)<r(s_j^l)$}
{	
$s_{j}^l$ aborts and retreats to $cp_j^l(\theta_{ij}^{kl})$\label{cpfblt-s_i^k first in m_set}\;
Remove all checkpoints in $s_j^l$ recorded after $cp_j^l(\theta_{ij}^{kl})$\label{cpfblt_step_rem_cp_jl}\;
}
{
$s_{i}^k$ aborts and retreats to $cp_i^k(\theta_{ij}^{kl})$\label{cpfblt-s_j^l first in m_set}\;
Remove all checkpoints in $s_i^k$ recorded after $cp_i^k(\theta_{ij}^{kl})$\label{cpfblt_step_rem_cp_ik_2}\;
}
}
}
\caption{The CPFBLT Algorithm}\label{cpfblt-algorithm}
\end{algorithm}
%
A new checkpoint is recorded for each newly accessed object $\theta$ by any transaction $s_h^u$ (step~\ref{cpfblt_step_add_new_cp}). Checkpoint is recorded when $\theta$ is accessed for the first time because any further changes to $\theta$ will be discarded upon conflict. Each transaction $s_{i}^{k}$ can be aborted during $T_i$ for at most $\delta_{i}^{k}$ times. $\eta_{i}^{k}$ records  the number of times $s_{i}^{k}$ has already been aborted up to now. If $s_i^k$ and $s_j^l$ have not joined the $m\_$set yet, then they are preemptive transactions. Preemptive transactions resolve conflicts using CPLCM (step~\ref{apply cplcm}). Thus, CPFBLT defaults to CPLCM when the conflicting transactions ($s_i^k$ and $s_j^l$) have not reached their $\delta$s ($\delta_i^k$ and $\delta_j^l$). $\eta_i^k$ is incremented each time $s_{i}^k$ is aborted as long as $\eta_i^k < \delta_i^k$ (steps~\ref{cpfblt-increment eta 1} and~\ref{cpfblt-increment eta 2}). Otherwise, $s_i^k$ is added to the $m\_$ set and priority of $s_{i}^k$ is increased to $m\_prio$ (steps~\ref{cpfblt-add to m_set 1} to~\ref{cpfblt-increase priority 1} and~\ref{cpfblt-add to m_set 2} to~\ref{cpfblt-increase priority 2}). When the priority of $s_i^k$ is increased to $m\_prio$, $s_i^k$ becomes a non-preemptive transaction. Non-preemptive transactions cannot be aborted by other preemptive transactions, nor by any other real-time job (steps~\ref{cpfblt-s_j^l is non preemptive} to~\ref{cpfblt-end preemptive and non preemptive}). On the other hand, non-preemptive transactions can abort each other. The $m\_$set can hold at most $m$ concurrent transactions because there are $m$ processors in the system. $r(s_i^k)$ records the time $s_i^k$ joined the $m\_$set (steps~\ref{cpfblt-record 1} and~\ref{cpfblt-record 2}). When non-preemptive transactions conflict together (step~\ref{cpfblt-both non preemptive}), the transaction that joined $m\_$set first becomes the transaction that commits first (steps~\ref{cpfblt-s_i^k first in m_set} and~\ref{cpfblt-s_j^l first in m_set}). When $s_i^k$ aborts due to a conflict on $\theta_{ij}^{kl}$ with $s_j^l$, then $s_i^k$ retreats to $cp_i^k(\theta_{ij}^{kl})$. All checkpoints recorded after $cp_i^k(\theta_{ij}^{kl})$ are removed (steps~\ref{cpfblt_step_rem_cp_ik_1}, and~\ref{cpfblt_step_rem_cp_ik_2}). Similarly, $s_j^l$ removes all checkpoints recorded after $cp_j^l(\theta_{ij}^{kl})$ if aborted by $s_i^k$ (step~\ref{cpfblt_step_rem_cp_jl}).

\section{CPFBLT Retry Cost}\label{sec:cpfblt rc}

\begin{clm}\label{clm:basic_rc}
Assume only two transaction $s_i^k$ and $s_j^l$ conflicting together. Let $s_i^k$ begins at time $S\left(s_i^k\right)$ and $s_j^l$ begins at time $S\left(s_j^l\right)$. Let $\triangle=S\left(s_j^l\right)-S\left(s_i^k\right)$. In the absence of checkpointing, retry cost of $s_i^k$ due to $s_j^l$ is given by
%
\begin{equation}
BASE\_RC_{ij}^{kl} \le \begin{cases}
len\left(s_{j}^{l}\right)+\triangle & ,-len\left(s_{j}^{l}\right)\le\triangle\le len\left(s_{i}^{k}\right)\\
0 & ,\, Otherwise
\end{cases}
\label{eq:base_rc}
\end{equation}
%
$BASE\_RC_{ij}^{kl}$ is upper bounded by 
\begin{equation}
len\left(s_j^l+s_i^k\right)\label{eq:upper_base_rc}
\end{equation}
%
which is the same upper bound given by Proofs of Claims 1 and 3 in~\cite{stmconcurrencycontrol:emsoft11}
\end{clm}
%
\begin{proof}
Due to absence of checkpointing, $s_i^k$ aborts and retries from its beginning due to $s_j^l$. So, $s_i^k$ retries for the period starting from $S\left(s_i^k\right)$ to the end of execution of $s_j^l$. $s_j^l$ ends execution at $S\left(s_j^l\right)+len\left(s_j^l\right)$. If $S\left(s_j^l\right)<S\left(s_i^k\right)-len\left(s_j^l\right)$, then $s_j^l$ finishes execution before start of $s_i^k$ and there will be no conflict. Also, if $S\left(s_j^l\right)>S\left(s_i^k\right)+len\left(s_i^k\right)$, then $s_j^l$ starts execution after $s_i^k$ finishes execution and there will be no conflict. Thus,~(\ref{eq:base_rc}) follows. Equation~(\ref{eq:upper_base_rc}) is derived by substitution of $\triangle$ by its maximum value (i.e., $\left(s_{i}^{k}\right)$). Claim follows.
\end{proof}
%
\begin{clm}\label{clm:2_tx_cp_retry_cost}
Assume only two transactions $s_i^k$ and $s_j^l$ conflicting on one object $\theta$. Let $\nabla_{j}^{l}$ be the time interval between the start of $s_{j}^{l}$ and the first access to $\theta$. Similarly, let $\nabla_{i}^{k}$ be the time interval between the start of $s_i^k$ and the first access to $\theta$. Let $\triangle$ be the time difference between start of $s_j^l$ to the start of $s_i^k$. So, $\triangle < 0$ if $s_j^l$ starts before $s_i^k$. Under checkpointing, $s_{i}^{k}$ aborts and retries due to $s_{j}^{l}$
for 
\begin{equation}
RC0_{ij}^{kl} \le \begin{cases}
len\left(s_{j}^{l}\right)-\nabla_{i}^{k}+\triangle & \mbox{, if }\begin{gathered}\triangle\ge\nabla_{i}^{k}-len\left(s_{j}^{l}\right)\\
\triangle\le len\left(s_{i}^{k}\right)-\nabla_{j}^{l}
\end{gathered}
\\
0 & \mbox{, Otherwise}
\end{cases}\label{eq:2_tx_cp_retry_cost}
\end{equation}
%
$RC0_{ij}^{kl}$ is upper bounded by 
\begin{equation}
len\left(s_{j}^{l}+s_{i}^{k}\right)-\nabla_{j}^{l}-\nabla_{i}^{k}\label{eq:rc0_upper_bound}
\end{equation}

\end{clm}
%
\begin{proof}
%
As $s_i^k$ and $s_j^l$ conflict only on one object $\theta$, there will be no conflict before both $s_i^k$ and $s_j^l$ access $\theta$. Retry cost of $s_i^k$ due to $s_j^l$ is derived by Claim~\ref{clm:basic_rc} excluding parts of $s_i^k$ and $s_j^l$ before both transactions access $\theta$. Thus, excluding the parts of $s_i^k$ and $s_j^l$ that do not cause conflict. So, $len\left(s_i^k\right)$ in Claim~\ref{clm:basic_rc} is substituted by $len\left(s_i^k\right)-\nabla_i^k$. $len\left(s_j^l\right)$ is substituted by $len\left(s_j^l\right)-\nabla_j^l$. $\triangle$ in Claim~\ref{clm:basic_rc} is substituted by $\triangle+\nabla_j^l-\nabla_i^k$. Claim follows.
%
\end{proof}
%
\begin{clm}\label{clm:rc1_upper_bound}
%
Assume only two transactions $s_i^k$ and $s_j^l$ conflicting on a number of objects $\theta_1,\,\theta_2\,...\,\theta_z$. Let $\nabla_{i*}^k$ be the time interval between start of $s_i^k$ and the first access to the first object accessed by $s_i^k$ and shared with $s_j^l$ (e.g., $\theta_i$). Let $\nabla_{j*}^l$ be the time interval between start of $s_j^l$ and the first access to the first object accessed by $s_j^l$ and shared with $s_i^k$ (e.g., $\theta_j$). $\theta_i$ and $\theta_j$ may not be the same. With checkpointing, retry cost of $s_i^k$ due to $s_j^l$ is upper bounded by 
%
\begin{equation}
RC1_{ij}^{kl} \le len\left(s_i^k+s_j^l\right)-\nabla_{i*}^k-\nabla_{j*}^l
\label{eq:rc1_upper_bound}
\end{equation}
%
\end{clm}
%
\begin{proof}
%
Proof follows directly from Claim~\ref{clm:2_tx_cp_retry_cost} by maximizing (\ref{eq:rc0_upper_bound}). $len\left(s_i^k\right)$, as well as, $len\left(s_j^l\right)$ in (\ref{eq:rc0_upper_bound}) cannot be changed. Thus, by choosing minimum values of $\nabla_i^k$ and $\nabla_j^l$ that correspond to shared objects between $s_i^k$ and $s_j^l$, (\ref{eq:rc0_upper_bound}) is maximized. Claim follows.
%
\end{proof}
%
\begin{clm}\label{clm:cp_with_transitive_retry}
If $s_j^l$ is conflicting indirectly (through transitive retry) with $s_i^k$, then it is safe to ignore $\nabla_{i*}^k$ in calculating the upper bound of retry cost of $s_i^k$ due to $s_j^l$.
\end{clm}
%
\begin{proof}
If $s_j^l$ is conflicting indirectly with $s_i^k$, then $s_j^l$ is accessing an object $\theta$ that does not belong to $\Theta_i^k$. In this case, to get an upper bound for the retry cost of $s_i^k$ due to $s_j^l$, $\nabla_{i*}^k$ assumes its minimum value in (\ref{eq:rc1_upper_bound}). Thus, $\nabla_{i*}^k=0$. Claim follows.
\end{proof}
%
\begin{clm}\label{clm:non_preemptive_2tx_cpfblt_rc}
Assume only two non-preemptive transactions $s_i^k$ and $s_j^l$ under CPFBLT. With checkpointing, retry cost of $s_i^k$ due to direct or indirect conflict with $s_j^l$ is upper bounded by 
%
\begin{equation}
RC2_{ij}^{kl} \le len\left(s_{j}^{l}\right)-\nabla_{i*}^{k}\label{eq:rc2_upper_bound}
\end{equation}
%
where $\nabla_{i*}^k=0$ in case of indirect conflict.
%
\end{clm}
%
\begin{proof}
Proof follows directly from Claims~\ref{clm:2_tx_cp_retry_cost},~\ref{clm:rc1_upper_bound} and~\ref{clm:cp_with_transitive_retry} except that $s_j^l$ must have become non-preemptive before $s_i^k$. So, $s_j^l$ starts execution non-preemptively before $s_i^k$. Otherwise, by definition of CPFBLT, $s_j^l$ will not be able to abort $s_i^k$. Thus, $\triangle$ must not exceed 0. Claim follows.
\end{proof}
%
\begin{clm}\label{clm:non_preemptive_all_tx_rc}
Let $s_i^k$ be a non-preemptive transaction under CPFBLT. Let $\chi_i^k$ be the set of transactions conflicting (directly or indirectly) with $s_i^k$. Each transaction $s_j^l \in \chi_i^k$ belongs to a distinct task. Transactions in $\chi_i^k$ are organized in non-increasing order of $RC2_{ij}^{kl}$ for each $s_j^l \in \chi_i^k$. Total retry cost of non-preemptive transaction $s_i^k$ due to other non-preemptive transactions is upper bounded by 
%
\begin{equation}
RC3_i^k \le \sum_{a=1}^{a=min\left(|\chi_i^k|, m-1\right)} RC2_i^k\left(\chi_i^k(a)\right)
\label{eq:non_preemptive_all_tx_rc}
\end{equation}
%
where $\chi_i^k(a)$ is the $a^{th}$ transaction in $\chi_i^k$. If $\chi_i^k(a)=s_j^l$, then $RC2_i^k\left(\chi_i^k(a)\right)=RC2_{ij}^{kl}$.
%
\end{clm}
%
\begin{proof}
By definition of CPFBLT, a transaction $s_i^k$ can be preceded by at most $m-1$ non-preemptive transactions. As non-preemptive transactions are organized in the order they become non-preemptive, no two non-preemptive transactions can belong to the same task. Maximum retry cost of non-preemptive $s_i^k$ occurs when: 1) $s_i^k$ is preceded by at most $m-1$ transactions conflicting with $s_i^k$. 2) Each conflicting transaction $s_j^l$ to $s_i^k$ must have one of the highest $m-1$ values for $RC2_{ij}^{kl}$. 3) Non-preemptive transactions preceding $s_i^k$ are executing sequentially. Thus, retry cost of non-preemptive $s_i^k$ can be upper bounded by Claim~\ref{clm:non_preemptive_2tx_cpfblt_rc} for at most the first $m-1$ transactions in $\chi_i^k$. If the third condition is not satisfied, then (\ref{eq:non_preemptive_all_tx_rc}) still gives a correct, but not tight, upper bound. Claim follows.
\end{proof}
%
\begin{clm}\label{clm:delta_ik_rc}
%
Under CPFBLT, a preemptive transaction $s_i^k$ aborts and retries for at most
\begin{equation}
RC4_i^k \le \delta_i^k \left(len\left(s_i^k\right)-min\left(\nabla_{i*}^k\right)\right)
\label{eq:delta_ik_rc}
\end{equation}
%
where $min\left(\nabla_{i*}^k\right)$ is the minimum $\nabla_{i*}^k$ for $s_i^k$ and any other conflicting transaction $s_j^l$. If there are indirectly conflicting transactions with $s_i^k$, then $min\left(\nabla_{i*}^k\right)=0$.
%
\end{clm}
%
\begin{proof}
%
No transaction will make preemptive $s_i^k$ aborts and retries before $min\left(\nabla_{i*}^k\right)$. By checkpointing, $s_i^k$ will not retreat earlier than $min\left(\nabla_{i*}^k\right)$. By definition of CPFBLT, preemptive $s_i^k$ aborts for at most $\delta_i^k$ times before it becomes non-preemptive. Claim follows.
\end{proof}
%
\begin{clm}\label{clm:closed_nested_fblt_final}
%
The total retry cost of any job $\tau_i^x$ under CPFBLT due to 1) conflicts with other transactions during an interval $L$. 2) release of higher priority jobs during execution of preemptive transactions is upper bounded by
%
\begin{equation}
RC(L)_{to}^i=\sum_{s_i^k \in s_i} \left(RC4_i^k + RC3_i^k \right) + RC_{re}(L)
\label{eq:cpfblt_final}
\end{equation}
where $RC_{re}(L)$ is the retry cost resulting from the release of higher priority jobs during execution of preemptive transactions. $RC_{re}(L)$ is calculated by Claim 1 in~\cite{fblt}.
%
\end{clm}
%
\begin{proof}
%
Following Claims~\ref{clm:cp_with_transitive_retry},~\ref{clm:non_preemptive_all_tx_rc},~\ref{clm:delta_ik_rc}  and Claim 1 in~\cite{fblt}, Claim follows.
%
\end{proof}
%
Any newly released task $\tau_{i}^{x}$ can be blocked by $m$ lower priority non-preemptive transactions. Blocking time $D_{i}$ of any job $\tau_i^x$ is independent of checkpointing. Thus, $D_i$ is calculated by Claim 3 in \cite{fblt}. Claim 2 in \cite{fblt} is used to calculate response time under CPFBLT where $RC_{to}(T_{i})$ is calculated by (\ref{eq:cpfblt_final}).
%
\section{CPFBLT vs. NCPFBLT}\label{sec:schedulabiltiy comparison}

\begin{clm}\label{clm:cp_ncp_fblt_schedulabiltiy_comp}
%
Schedulability of CPFBLT is better or equal to schedulability of NCPFBLT if shared objects within each transaction $s_i^k$ are accessed close to the end of execution $s_i^k$.
%
\end{clm}
%
\begin{proof}
%
Let upper bound on retry cost of any task $\tau_{i}^{x}$ during $T_{i}$ under NCPFBLT be denoted as $RC_{i}^{ncp}$. $RC_{i}^{ncp}$ is calculated by Claim 1 in \cite{fblt}. Let upper bound on retry cost of any task $\tau_{i}^{x}$ during $T_{i}$ under CPFBTL be denoted as $RC_{i}^{cp}$. $RC_{i}^{cp}$ is calculated by (\ref{eq:cpfblt_final}). Let $D_{i}$ be the upper bound on blocking time of any newly released task $\tau_{i}^{x}$ during $T_{i}$ due to lower priority jobs. $D_{i}$ is the same for both CPFBLT and NCPFBLT. $D_{i}$ is calculated by Claim 2 in \cite{fblt}. For CPFBLT schedulability to be better than schedulability of NCPFBLT: 
%
\begin{equation}
\sum_{\forall\tau_{i}}\frac{c_{i}+RC_{i}^{cp}+D_{i}}{T_{i}}\le\sum_{\forall\tau_{i}}\frac{c_{i}+RC_{i}^{ncp}+D_{i}}{T_{i}}\label{eq:schedulability_comparison}
\end{equation}
$\because$ $D_{i}$ and $c_{i}$ are the same for each $\tau_{i}$
under CPFBLT and NCPFBLT, then (\ref{eq:schedulability_comparison})
holds if:
\[
\forall\tau_{i},\, RC_{i}^{cp}\le RC_{i}^{ncp}
\]
%
\begin{eqnarray}
 & \delta_{i}^{k}\left(len\left(s_{i}^{k}\right)-min\left(\nabla_{i*}^{k}\right)\right)+\sum_{a=1}^{min\left(|\chi_{i}^{k}|,m-1\right)}\left(len\left(\chi_{i}^{k}(a)\right)-\nabla_{i*}^{k}\right)\nonumber\\
\le & \delta_{i}^{k}len\left(s_{i}^{k}\right)+\sum_{a=1}^{min\left(|\gamma_{i}^{k}|,m-1\right)}\left(len\left(\gamma_{i}^{k}(a)\right)\right)
\label{eq:cpfblt_vs_ncpfblt_1}
\end{eqnarray}
%
where $\gamma_i^k$ is the set of at most $m-1$ longest transactions conflicting directly or indirectly with $s_i^k$. Thus, $\gamma_i^k(a) \ge \chi_i^k(a), \forall a$. Thus, by increasing $\nabla_{i*}^k$, (\ref{eq:cpfblt_vs_ncpfblt_1}) holds. Claim follows.
%
\end{proof}
%
\section{Experimental Evaluation}\label{exp_eval}
%
We now would like to understand how CPFBLT's retry cost and response time compare with NCPFBLT in practice. Since this can only be understood experimentally, we implement CPFBLT and NCPFBLT and conduct experiments. 

We used the ChronOS real-time Linux kernel~\cite{dellinger2011chronos} and the Rochester STM (RSTM) library~\cite{marathe2006lowering} in our implementation. We implemented G-EDF and G-RMA schedulers in ChronOS, and modified RSTM to include implementations of CPFBLT and NCPFBLT. Checkpointing is implemented using \textit{setjmp/longjmp} instructions. When an object $\theta$ is accessed for the first time, \textit{setjmp} is used to record a checkpoint. Additionally, a copy of the object is recorded to be restored in case of partial abort. A transaction partially aborts using \textit{longjmp}. We used an 8 core, 2GHz AMD Opteron platform. We used three task sets consisting of 4, 8, and 20 periodic tasks. Each task runs in its own thread and has a set of atomic sections. Atomic section properties are controlled using three parameters: the maximum ($max$) and minimum ($min$) lengths of any atomic section within a task, and the total length ($total$) of atomic sections within any task. Each one of $min,\,max,\,total$ lies in $\{0.2,0.5,0.8\}$ provided that $min \le max \le total$. For each run, $\xoverline{rt\left(\nabla\right)}=max(1-rt\left(\nabla_{i*}^k)\right)_{\forall s_i^k}$ lies within $\{0,0.2,0.4,0.6,0.8\}$. $\xoverline{rt\left(\nabla\right)}$ represents the maximum ratio of $len(s_i^k),
\,\forall s_i^k$ after which accessed objects by $s_i^k$ can be shared with other transactions.
%
\begin{figure}
\centering
\subfigure[4 tasks, G-EDF, Response time]{
\scalebox{0.75}{\input{/e/lectures/real-time/PhD-work/STM/Dropbox/Practical/results_uno/figures/4_tasks/Res_Time/fblt/NCP_vs_CP_Res_4t_50obj_100wr_-1eta_gedf.tex}
}
\label{fig:4t_gedf_res}
}
%~
\subfigure[4 tasks, G-RMA, Response time]{
\scalebox{0.75}{\input{/e/lectures/real-time/PhD-work/STM/Dropbox/Practical/results_uno/figures/4_tasks/Res_Time/fblt/NCP_vs_CP_Res_4t_50obj_100wr_-1eta_grma.tex}
}
\label{fig:4t_grma_res}
}
\caption{Response time difference between NCPFBLT and CPFBLT for 4 tasks.}
\label{fig:4t_res}
\end{figure}
%
\begin{figure}
\centering
\subfigure[8 tasks, G-EDF, Response time]{
\scalebox{0.75}{\input{/e/lectures/real-time/PhD-work/STM/Dropbox/Practical/results_uno/figures/8_tasks/Res_Time/fblt/NCP_vs_CP_Res_8t_90obj_100wr_-1eta_gedf.tex}
}
\label{fig:8t_gedf_res}
}
%
\subfigure[20 tasks, G-EDF, Response time]{
\scalebox{0.75}{\input{/e/lectures/real-time/PhD-work/STM/Dropbox/Practical/results_uno/figures/20_tasks/Res_Time/fblt/NCP_vs_CP_Res_20t_210obj_100wr_-1eta_gedf.tex}
}
\label{fig:20t_gedf_res}
}
%~
\begin{comment}
\subfigure[8 tasks, G-RMA, Response time]{
\scalebox{0.75}{\input{/e/lectures/real-time/PhD-work/STM/Dropbox/Practical/results_uno/figures/8_tasks/Res_Time/fblt/NCP_vs_CP_Res_8t_90obj_100wr_-1eta_grma.tex}
}
\label{fig:8t_grma_res}
}
\end{comment}
\caption{Response time difference between NCPFBLT and CPFBLT under G-EDF for a) 8 tasks. b) 20 tasks.}
\label{fig:8t_res}
\end{figure}
%
\begin{comment}
\begin{figure}
\centering
\subfigure[20 tasks, G-EDF, Response time]{
\scalebox{0.75}{\input{/e/lectures/real-time/PhD-work/STM/Dropbox/Practical/results_uno/figures/20_tasks/Res_Time/fblt/NCP_vs_CP_Res_20t_210obj_100wr_-1eta_gedf.tex}
}
\label{fig:20t_gedf_res}
}
%~
\subfigure[20 tasks, G-RMA, Response time]{
\scalebox{0.75}{\input{/e/lectures/real-time/PhD-work/STM/Dropbox/Practical/results_uno/figures/20_tasks/Res_Time/fblt/NCP_vs_CP_Res_20t_210obj_100wr_-1eta_grma.tex}
}
\label{fig:20t_grma_res}
}
\caption{Response time difference between NCPFBLT and CPFBLT for 20 tasks.}
\label{fig:20t_res}
\end{figure}
\end{comment}
%
%
\begin{figure}
\centering
\subfigure[4 tasks, G-EDF, Retry cost]{
\scalebox{0.75}{\input{/e/lectures/real-time/PhD-work/STM/Dropbox/Practical/results_uno/figures/4_tasks/Abr_Dur/fblt/NCP_vs_CP_Abr_dur_4t_50obj_100wr_-1eta_gedf.tex}
}
\label{fig:4t_gedf_rc}
}
%~
\subfigure[4 tasks, G-RMA, Retry cost]{
\scalebox{0.75}{\input{/e/lectures/real-time/PhD-work/STM/Dropbox/Practical/results_uno/figures/4_tasks/Abr_Dur/fblt/NCP_vs_CP_Abr_dur_4t_50obj_100wr_-1eta_grma.tex}
}
\label{fig:4t_grma_rc}
}
\caption{Retry cost difference between NCPFBLT and CPFBLT for 4 tasks.}
\label{fig:4t_rc}
\end{figure}
%
%
\begin{figure}
\centering
\subfigure[8 tasks, G-EDF, Retry cost]{
\scalebox{0.75}{\input{/e/lectures/real-time/PhD-work/STM/Dropbox/Practical/results_uno/figures/8_tasks/Abr_Dur/fblt/NCP_vs_CP_Abr_dur_8t_90obj_100wr_-1eta_gedf.tex}
}
\label{fig:8t_gedf_rc}
}
%~
\subfigure[20 tasks, G-EDF, Retry cost]{
\scalebox{0.75}{\input{/e/lectures/real-time/PhD-work/STM/Dropbox/Practical/results_uno/figures/20_tasks/Abr_Dur/fblt/NCP_vs_CP_Abr_dur_20t_210obj_100wr_-1eta_gedf.tex}
}
\label{fig:20t_gedf_rc}
}
%
\begin{comment}
\subfigure[8 tasks, G-RMA, Retry cost]{
\scalebox{0.75}{\input{/e/lectures/real-time/PhD-work/STM/Dropbox/Practical/results_uno/figures/8_tasks/Abr_Dur/fblt/NCP_vs_CP_Abr_dur_8t_90obj_100wr_-1eta_grma.tex}
}
\label{fig:8t_grma_rc}
}
\end{comment}
\caption{Retry cost difference between NCPFBLT and CPFBLT under G-EDF for a) 8 tasks. b) 20 tasks.}
\label{fig:8t_rc}
\end{figure}
%
\begin{comment}
\begin{figure}
\centering
\subfigure[20 tasks, G-EDF, Retry cost]{
\scalebox{0.75}{\input{/e/lectures/real-time/PhD-work/STM/Dropbox/Practical/results_uno/figures/20_tasks/Abr_Dur/fblt/NCP_vs_CP_Abr_dur_20t_210obj_100wr_-1eta_gedf.tex}
}
\label{fig:20t_gedf_rc}
}
%~
\subfigure[20 tasks, G-RMA, Retry cost]{
\scalebox{0.75}{\input{/e/lectures/real-time/PhD-work/STM/Dropbox/Practical/results_uno/figures/20_tasks/Abr_Dur/fblt/NCP_vs_CP_Abr_dur_20t_210obj_100wr_-1eta_grma.tex}
}
\label{fig:20t_grma_rc}
}
\caption{Retry cost difference between NCPFBLT and CPFBLT for 20 tasks.}
\label{fig:20t_rc}
\end{figure}
\end{comment}
%
Response time difference between NCPFBLT and CPFBLT for the 4, 8 and 20 task sets are shown in figures~\ref{fig:4t_res} and~\ref{fig:8t_res}. Response time for 8 and 20 tasks under G-RMA show the same trend as response time under G-EDF for 8 and 20 tasks. Response time for 8 and 20 tasks under G-RMA are not shown here due to space limitation. Results show benefits of checkpointing when combined with FBLT. As $\bar{\nabla}=0$, then all objects accessed by $s_i^k$ can be shared with other transactions. Consequently, $s_i^k$ retreats to its beginning, under both CPFBLT and NCPFBLT, if contended objects are accessed at the beginning of $s_i^k$. Thus, NCPFBLT can show better response time than CPFBLT as shown in the figures.

Figures~\ref{fig:4t_rc} and~\ref{fig:8t_rc} show retry cost difference between NCPFBLT and CPFBLT. Retry cost for 8 and 20 tasks under G-RMA show the same trend as retry cost under G-EDF for 8 and 20 tasks. Retry cost for 8 and 20 tasks under G-RMA are not shown here due to space limitation. Retry cost results can be misleading because of the negative difference between retry cost of NCPFBLT and CPFBLT. But this is natural due to behaviour of CPFBLT. Under NCPFBLT, a transaction $s_i^k$ returns to its beginning upon a conflict with $s_j^l$ on object $\theta$. Whereas, under CPFBLT, $s_i^k$ returns to the first point it accessed $\theta$. Thus, under CPFBLT, $s_i^k$ tries to access $\theta$ directly after returning to the proper checkpoint. But $s_j^l$ is still holding $\theta$. Accordingly, $s_i^k$ will abort and retry again. This retrial (donated as $RC_{cp}s_i^k$) is added to the accumulated retry cost of $s_i^k$ under CPFBLT. Under NCPFBLT, $s_i^k$ returns to its beginning when it conflicts with $s_j^l$. Thus, when $s_i^k$ reaches $\theta$ once again, $s_j^l$ may have finished execution. Thus, $s_i^k$ will not have to abort again due to a conflict with $s_j^l$ upon $\theta$. Let the time between start of $s_i^k$ and first access to $\theta$ be $\nabla_i^k(\theta)$. Accordingly, retry cost of $s_i^k$ under NCPFBLT can be less than retry cost of $s_i^k$ under CPFBLT. Whereas, $RC_{cp}s_i^k$ can be much less than $\nabla_i^k(\theta)$. Thus, $RC_{cp}s_i^k$ contributes by a smaller value to the response time of $\tau_i$, in contrast to $\nabla_i^k(\theta)$. This why response time for CPFBLT is better than NCPFBLT, whereas, retry cost of NCPFBLT is less than CPFBLT.
%
\section{Conclusion}\label{sec:conclusion}
%
Past research on real-time CMs focused on devloping different conflict resultion strategis for transactions. Except for LCM~\cite{lcmdac2012}, no policy was made to reduce the length of conflicting transactions. In this paper, we analysed effect of checkpointing over FBLT CM. Analysis shows that response time of CPFBLT can be reduced than NCPFBLT if shared objects are accessed close to the end of execution of each transaction. Experimental evaluation reveals better response time for CPFBLT than NCPFBLT. Despite retry cost of NCPFBLT is lower than retry cost of CPFBLT, but this is natural as explained previously. Some CMs make no use of checkpointing due to behaviour of that CM (e.g, under PNF, all non-preemptive transactions are non-conflicting).
% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://www.ctan.org/tex-archive/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
\bibliography{IEEEabrv,/e/lectures/real-time/PhD-work/STM/Dropbox/writing/global_bibliography/global_bibliography}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)

% that's all folks
\end{document}


