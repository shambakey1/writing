% acmsmall-sample.tex, dated 24th May 2012
% This is a sample file for ACM small trim journals
%
% Compilation using 'acmsmall.cls' - version 1.3, Aptara Inc.
% (c) 2010 Association for Computing Machinery (ACM)
%
% Questions/Suggestions/Feedback should be addressed to => "acmtexsupport@aptaracorp.com".
% Users can also go through the FAQs available on the journal's submission webpage.
%
% Steps to compile: latex, bibtex, latex latex
%
% For tracking purposes => this is v1.3 - May 2012

\documentclass[prodmode,acmtecs]{acmsmall}

% Package to generate and customize Algorithm as per ACM style
\usepackage {paralist}
\usepackage{comment}
\usepackage{cite}
\usepackage{subfigure}
\usepackage{url}
\usepackage{graphicx}
\usepackage[ruled]{algorithm2e}
\renewcommand{\algorithmcfname}{ALGORITHM}
\newtheorem{clm}{Claim}
\newtheorem{mydef}{Definition}
\SetAlFnt{\small}
\SetAlCapFnt{\small}
\SetAlCapNameFnt{\small}
\SetAlCapHSkip{0pt}
\IncMargin{-\parindent}

% Metadata Information
\acmVolume{}
\acmNumber{}
\acmArticle{}
\acmYear{}
\acmMonth{}

% Document starts
\begin{document}

% Page heads
\markboth{M. Elshambakey et al.}{FBLT}

% Title portion
\title{FBLT}
\author{Mohammed Elshambakey
\affil{Virginia Tech University}
Binoy Ravindran
\affil{Virginia Tech University}}

\begin{abstract}
\bf{NEEDS TO BE WRITTEN}
\end{abstract}

\category{C.3}{Special-Purpose and Application-based Systems}{Real-time and embedded systems}

\terms{Design, Experimentation, Measurement}

\keywords{Software transactional memory (STM), real-time contention manager}

\acmformat{Elshambakey, M., Binoy, R. 2012. FBLT.}

\begin{bottomstuff}
New Paper, Not an Extension of a Conference Paper.\\
Author's addresses: M. Elshambakey {and} B. Ravindran, ECE Department,
Virginia Tech University, Blacksburg, VA 24060, USA.
\end{bottomstuff}

\maketitle


\section{Introduction}

\label{sec:intro}

Embedded systems sense physical processes and control their behavior, typically through feedback loops. Since physical processes are concurrent, computations that control them must also be concurrent, enabling them to process multiple streams of sensor input and control multiple actuators, all concurrently. Often, such computations need to concurrently read/write shared data objects. They must also process sensor input and react, while satisfying time constraints. 

The de facto standard for concurrent programming is the threads abstraction, and the 
de facto synchronization abstraction is locks. Lock-based concurrency control has significant programmability, scalability, and composability challenges~\cite{Herlihy:2006:AMP:1146381.1146382}. Software transactional memory (STM) is an alternative synchronization model for shared memory data objects that promises to alleviate these difficulties. With STM, code that read/write shared objects is organized as transactions, which execute speculatively, while logging changes made to objects. Two transactions conflict if they access the same object and one access is a write. When that happens, a contention manager (CM)~\cite{Guerraoui:2005:TTT:1073814.1073863} resolves the conflict by aborting one and allowing the other to commit, yielding (the illusion of) atomicity. Aborted transactions are re-started, after rolling back the changes. In addition to a simple programming model, STM provides performance comparable to locking and lock-free approaches (see an example STM system's performance in~\cite{Saha:2006:MHP:1122971.1123001}), and is composable~\cite{Harris:2005:CMT:1065944.1065952}. TM has been proposed in hardware, called HTM, and in software, called STM, with the usual tradeoffs: HTM has lesser overhead, but needs transactional support in hardware; STM is available on any hardware.

Given STM's programmability, scalability, and composability advantages, it is a compelling concurrency control technique also for multicore embedded real-time software. However, this requires  bounding transactional  retries, as real-time threads, which subsume transactions, must satisfy time constraints.  Retry bounds under STM are dependent on the CM policy at hand (analogous to the way thread response time bounds are OS scheduler-dependent). 

Past real-time CM research has proposed resolving transactional contention using dynamic and fixed priorities of parent threads, resulting in EDF-based CM (ECM) and RMS-based CM (RCM), respectively~\cite{6045438,stmconcurrencycontrol:emsoft11,lcmdac2012}.
In particular,~\cite{stmconcurrencycontrol:emsoft11} shows that ECM and RCM achieve higher schedulability -- i.e., greater number of task sets meeting their time constraints -- than lock-free synchronization only under some ranges for the maximum atomic section length. That range is significantly expanded with the LCM contention manager in~\cite{lcmdac2012}, increasing the coverage of STM's timeliness superiority. However, these works restrict to \textit{one} object access per transaction, which is a major limitation. 

To allow multiple objects per transaction, Priority CM with Negative value and First access (PNF)  was introduced~\cite{shambake_phd_proposal}. PNF can be used with global EDF (G-EDF) and global RMA (G-RMA) multicore real-time schedulers~\cite{Davis:2011:SHR:1978802.1978814}. PNF requires priori knowledge of accessed objects by each transaction. This is not suitable with dynamic software transactional memory~\cite{Herlihy:2003:STM:872035.872048}.

We introduce First Blocked, Last Timestamp (FBLT) CM (Section~\ref{sec:fblt design}). Overview about previous contention managers and their limitations that led to FBLT is given in Section~\ref{sec:motivation}. FBLT combines benefits of LCM and PNF. FBLT reduces retry cost of a single transaction due to another transaction. FBLT can handle multiple objects per transaction better than ECM, RCM and LCM. In contrast to PNF, FBLT does not require prior knowledge of accessed objects by each transaction. Implementation of FBLT is simpler than PNF. FBLT is a decentralized CM that does not use locks in implementation. We establish FBLT's retry and response time upper bounds with G-EDF and G-RMA (Section~\ref{fblt rc}) schedulers. We identify the conditions under which FBLT outperforms ECM (Section~\ref{sec:fblt vs ecm}), RCM (Section~\ref{sec:fblt vs rcm}), G-EDF/LCM (Section~\ref{sec:fblt vs gedf lcm}), G-RMA/LCM (Section~\ref{fblt vs grma lcm}), PNF (Section~\ref{sec:fblt vs pnf}) and lock-free (Section~\ref{sec:fblt vs lock free}).
We implement FBLT and competitor CM techniques in the Rochester STM framework~\cite{marathe2006lowering} and conduct experimental studies (Section~\ref{exp_eval})

\section{Related Work}
\label{sec:past}

Transactional-like concurrency control without using locks, for real-time systems, has been previously studied in the context of non-blocking data structures (e.g.,~\cite{anderson95realtime}). Despite their numerous advantages over locks 
(e.g., deadlock-freedom), 
their programmability has remained a challenge. 
Past studies show that they are best suited for simple data structures where their retry cost is competitive to the cost of lock-based synchronization~\cite{bc+08}.  In contrast, STM is semantically simpler~\cite{Herlihy:2006:AMP:1146381.1146382}, and is often the only viable lock-free solution for complex data structures (e.g., red/black tree)~\cite{key-1} and nested critical sections~\cite{Saha:2006:MHP:1122971.1123001}.

STM concurrency control for real-time systems has been previously studied in~\cite{manson2006preemptible,fahmy2009bounding,sarni2009real,schoeberl2010rttm,key-1,barrosmanaging,stmconcurrencycontrol:emsoft11,lcmdac2012,shambake_phd_proposal}.


\cite{manson2006preemptible} proposes a restricted version of STM for uniprocessors. Uniprocessors do not need contention management. \cite{fahmy2009bounding} bounds response times in distributed  systems with STM synchronization. They consider Pfair scheduling, limit to small atomic regions with fixed size, and limit transaction execution to span at most two quanta. In contrast, we allow transaction lengths with  arbitrary duration. 

\cite{sarni2009real} presents real-time scheduling of transactions and serializes transactions based on deadlines. However, the work does not bound retries and response times. In contrast, we establish such bounds. \cite{schoeberl2010rttm} proposes real-time HTM. The work does not describe how transactional conflicts are resolved. Besides, the retry bound assumes that the worst case conflict between atomic sections of different tasks occurs when the sections are released at the same time. However, we show that this is not the worst case. We develop retry and response time upper bounds based on much worse conditions.


\cite{key-1} upper bounds retries and response times for  ECM with G-EDF, and identify the tradeoffs with locking and lock-free protocols. Similar to~\cite{schoeberl2010rttm},~\cite{key-1} also assumes that the worst case conflict between atomic sections occurs when the sections are released simultaneously. The ideas in~\cite{key-1} are extended in~\cite{barrosmanaging}, which presents three real-time CM designs. But no retry bounds or schedulability analysis techniques are presented for those CMs. 

\cite{stmconcurrencycontrol:emsoft11} presents the ECM and RCM contention managers, and upper bounds transactional retries and task response times under them. The work also identifies the conditions under which ECM and RCM are superior to locking and lock-free techniques. In particular, \cite{stmconcurrencycontrol:emsoft11} shows that, STM's superiority holds only under some ranges for the maximum atomic section length.  Moreover,~\cite{stmconcurrencycontrol:emsoft11} restricts transactions to access only one object.
%SH-ST
\cite{lcmdac2012} presents length-based CM (LCM), and upper bounds transactional retries and response time for G-EDF/LCM and G-RMA/LCM.~\cite{lcmdac2012} compares (analytically and experimentally) between ECM, RCM and LCM, as well as lock-free and LCM.~\cite{lcmdac2012}, as~\cite{stmconcurrencycontrol:emsoft11}, restricts transactions to access only one object.

\cite{shambake_phd_proposal} presents Priority CM with Negative value and First Access (PNF). PNF was designed to avoid transitive retry effect when each transaction accesses multiple objects. PNF also optimizes processor usage by reducing priority of retrying transactions below priorities of any real-time task. PNF requires prior knowledge of accessed objects by each transaction which is not always available. Besides, PNF is a centralized CM that uses locks in its implementation. Accordingly, reduction in retry cost is wasted by high overhead. \cite{shambake_phd_proposal} upper bounds transactional retries and response time for G-EDF and G-RMA. \cite{shambake_phd_proposal} compares (analytically and experimentally) between PNF and ECM, RCM, LCM and lock-free.

Our work builds upon~\cite{stmconcurrencycontrol:emsoft11,lcmdac2012,shambake_phd_proposal}, allows multiple objects per transaction with no prior knowledge about these objects. We upper bound transactional retries and task response times. We identify the conditinos for better schedulability for FBLT than other synchronization techniques.
%SH-END
\section{Preliminaries}
\label{sec:model}

We consider a multiprocessor system with $m$ identical processors and $n$ sporadic tasks $\tau_1, \tau_2,\ldots, \tau_n$. The $k^{th}$ instance (or job) of a task $\tau_i$ is denoted $\tau_i^k$. Each task $\tau_i$ is specified by its worst case execution time (WCET) $c_i$, its minimum period $T_i$ between any two consecutive instances, and its relative deadline $D_i$, where $D_i=T_i$. Job $\tau_i^j$ is released at time $r_i^j$ and must finish no later than its absolute deadline $d_i^j=r_i^j+D_i$. Under a fixed priority scheduler such as G-RMA, $p_i$ determines $\tau_i$'s (fixed) priority and it is constant for all instances of $\tau_i$. Under a dynamic priority scheduler such as G-EDF, a job $\tau_i^j$'s priority, $p_i^j$, differs from one instance to another. 
A task $\tau_j$ may interfere with task $\tau_i$ for a number of times during an interval $L$, and this number is denoted as $G_{ij}(L)$. 


\textit{Shared objects.}
 A task may need to read/write shared, in-memory data objects while it is executing any of its atomic sections (transactions), which are synchronized using STM. 
The set of atomic sections of task $\tau_i$ is denoted $s_i$. $s_i^k$ is the $k^{th}$ atomic section of $\tau_i$. 
Each object, $\theta$, can be accessed by multiple tasks. The set of distinct objects accessed by $\tau_i$ is $\theta_i$ without repeating objects.
The set of atomic sections used by $\tau_i$ to access $\theta$ is $s_i(\theta)$, and the sum of the lengths of those atomic sections is $len(s_i(\theta))$. $s_i^k(\theta)$ is the $k^{th}$ atomic section of $\tau_i$ that accesses $\theta$.
%SH-ST
 $s_i^k$ can access one or more objects in $\theta_i$. So, $s_i^k$ refers to the transaction itself regardless of accessed objects by this transaction. We denote the set of all accessed objects by $s_i^k$ as $\Theta_i^k$. While $s_i^k(\theta)$ means that $s_i^k$ accesses a specific object $\theta \in \Theta_i^k$, $s_i^k(\Theta)$ means that $s_i^k$ accesses a set of objects $\Theta=\{\theta \in \Theta_i^k$ \}. $\bar{s_i^k}=\bar{s_i^k}(\Theta)$ refers only once to $s_i^k$ regardless of number of objects in $\Theta$. So, $|\bar{s_i^k}(\Theta)|_{\forall \theta \in \Theta}=1$.
%SH-END
 $s_i^k(\theta)$  executes for a duration $len(s_i^k(\theta))$. $len(s_i^k)=len(s_i^k(\theta))=len(s_i^k(\Theta))=len(s_i^k(\Theta_i^k))$ The set of tasks sharing $\theta$ with $\tau_i$ is denoted $\gamma_i(\theta)$. The set of tasks sharing objects with $\tau_i$ is denoted as $\gamma_i$.

Atomic sections are non-nested (supporting nested STM is future work). The maximum-length atomic section in $\tau_i$ that accesses $\theta$ is denoted $s_{i_{max}} (\theta)$, while the maximum one among all tasks is $s_{max} (\theta)$, and the maximum one among tasks with priorities lower than that of $\tau_i$ is $s_{max}^i (\theta)$.

\textit{STM retry cost.} If two or more atomic sections conflict, the CM will commit one section and abort and retry the others, increasing the time to execute the aborted sections. The increased time that an atomic section $s_i^p (\theta)$ will take to execute due to a conflict with another section $s_j^k (\theta)$, is denoted $W_{i}^{p}(s_{j}^{k}(\theta))$. If an atomic section, $s_i^p$, is already executing, and another atomic section $s_j^k$ tries to access a shared object with $s_i^p$, then $s_j^k$ is said to ``interfere" or ``conflict" with $s_i^p$. The job $s_j^k$ is the ``interfering job", and the job $s_i^p$ is the ``interfered job".
%SH-ST
 Due to \textit{transitive retry} (introduced in Section~\ref{pnf overview}), an atomic section $s_i^k(\Theta_i^k)$ may retry due to another atomic section $s_j^l(\Theta_j^l)$ where $\Theta_i^k \cap \Theta_j^l = \emptyset$. $\theta_i^*$ denotes the set of objects not accessed directly by atomic sections in $\tau_i$ but can cause transactions in $\tau_i$ to retry due to transitive retry. $\theta_i^{ex}(=\theta_i + \theta_i^*)$ is the set of all objects that can cause transactions in $\tau_i$ to retry directly or through transitive retry. $\gamma_i^*$ is the set of tasks that access objects in $\theta_i^*$. $\gamma_i^{ex}(=\gamma_i + \gamma_i^*)$ is the set of all tasks that can can directly or indirectly (through transitive retry) cause transactions in $\tau_i$ to abort and retry.
%SH-END  
The total time that a task $\tau_i$'s atomic sections have to retry over $T_i$ is denoted $RC(T_i)$. The additional amount of time that all interfering jobs of $\tau_j$ causes to response time of any job of $\tau_i$ during $L$, without considering retries due to atomic sections, is denoted $W_{ij}(L)$.


\section{Motivation}
\label{sec:motivation}
To understand the need for FBLT, we give a brief introduction about previous CMs.

\subsection{ECM and RCM}
\textit{Earliest Deadline Contention Manager (ECM)} \cite{stmconcurrencycontrol:emsoft11} is used with G-EDF. ECM allows the transaction with the shortest absolute deadline to commit first. The others retry and abort. RCM \cite{stmconcurrencycontrol:emsoft11} is used with G-RMA. \textit{Rate Monotonic Contention Manager (RCM)} allows the transaction with the shortest period to commit first. ECM and RCM maintains consistency with the underlying scheduler.

\subsection{LCM}

For both ECM and RCM, $s_{i}^{k}(\theta)$ can be totally repeated if $s_{j}^{l}(\theta)$ --- which belongs to a higher priority job $\tau_{j}^b$ than $\tau_{i}^a$ --- conflicts with $s_{i}^{k}(\theta)$
at the end of its execution, while $s_{i}^{k}(\theta)$ is just about
to commit. Thus, \textit{Length-based Contention Manager (LCM)}~\cite{lcmdac2012}, shown in Algorithm~\ref{alg_lcm}, uses the remaining length of $s_{i}^{k}(\theta)$ when it is interfered,
as well as $len(s_{j}^{l}(\theta))$, to decide which transaction must be aborted. If $p_i^k$ was greater than $p_j^l$, then $s_i^k(\theta)$ would be the one that commits, because it belongs to a higher priority job, and it started before $s_j^l(\theta)$ (step~\ref{step_sicommits}). Otherwise, $c_{ij}^{kl}$ is calculated (step~\ref{step_cijkl}) to determine whether it is worth aborting $s_i^k(\theta)$ in favor of $s_j^l(\theta)$, because $len(s_j^l(\theta))$ is relatively small compared to the remaining execution length of $s_i^k(\theta)$.~\cite{lcmdac2012} assumes that:
\begin{equation}
c_{ij}^{kl}=len(s_{j}^{l}(\theta))/len(s_{i}^{k}(\theta))
\label{cm_eq}\end{equation}
where $c_{ij}^{kl}\in]0,\infty[$, to cover all possible lengths of $s_{j}^{l}(\theta)$.
The idea is to reduce the opportunity for the abort of $s_{i}^{k}(\theta)$ if it is close to committing when interfered and $len(s_{j}^{l}(\theta))$ is large. This abort opportunity is increasingly reduced as $s_{i}^{k}(\theta)$ gets closer to the end of its execution, or $len(s_{j}^{l}(\theta))$ gets larger. On the other hand, as $s_{i}^{k}(\theta)$ is interfered early, or $len(s_{j}^{l}(\theta))$ is small compared to $s_{i}^{k}(\theta)$'s remaining length, the abort opportunity is increased even if $s_i^k (\theta)$ is close to the end of its execution. To decide whether $s_{i}^{k}(\theta)$ must be aborted or not, a threshold value $\psi\in[0,1]$ that determines $\alpha_{ij}^{kl}$ (step~\ref{step_alphaijkl}), where $\alpha_{ij}^{kl}$ is the maximum percentage of $len(s_i^k(\theta))$ below which $s_j^l(\theta)$ is allowed to abort $s_i^k(\theta)$. Thus, if the already executed part of $s_i^k(\theta)$ --- when $s_j^l(\theta)$ interferes with $s_i^k(\theta)$ --- does not exceed $\alpha_{ij}^{kl}len(s_i^k(\theta))$, then $s_i^k(\theta)$ is aborted (step~\ref{step_siaborts}). Otherwise, $s_j^l(\theta)$ is aborted (step~\ref{step_sjaborts}).

\begin{algorithm}
\footnotesize{
\LinesNumbered
\KwData{$s_i^k(\theta)\rightarrow$ interfered atomic section.\\$s_j^l(\theta)\rightarrow$ interfering atomic section.\\$\psi\rightarrow$ predefined threshold $\in [0,1]$.\\$\delta_i^k(\theta)\rightarrow$ remaining execution length of $s_i^k(\theta)$}
\KwResult{which atomic section of $s_i^k(\theta)$ or $s_j^l(\theta)$ aborts}
\eIf{$p_i^k > p_j^l$}
	{$s_j^l(\theta)$ aborts\label{step_sicommits}\;}
	{$c_{ij}^{kl}=len(s_j^l(\theta))/len(s_i^k(\theta))$\label{step_cijkl}\;
	$\alpha_{ij}^{kl}=ln(\psi)/(ln(\psi)-c_{ij}^{kl})$\label{step_alphaijkl}\;
	$\alpha=\left(len(s_i^k(\theta))-\delta_i^k(\theta)\right)/len(s_i^k(\theta))$\;
	\eIf{$\alpha \le \alpha_{ij}^{kl}$}
	{$s_i^k(\theta)$ aborts\label{step_siaborts}\;}
	{$s_j^l(\theta)$ aborts\label{step_sjaborts}\;}
	}
	}
\caption{LCM}
\label{alg_lcm}
\end{algorithm}

LCM reduces retry cost of a single transaction $s_i^k(\theta)$ due to another transaction $s_j^l(\theta)$ from $2.s_{max}$ (in case of ECM and RCM) to $(1+\alpha_{max}).s_{max}$, where $s_{max}$ is the maximum length transaction among all tasks, and $\alpha_{max}$ is the maximum $alpha$ for any transaction. On the other side, LCM suffers from bounded priority inversion because a higher priority transaction can be blocked by a lower priority one. LCM is not a centralized CM, which means that, upon a conflict, each transactions has to decide whether it must commit or abort. 


\subsection{PNF}
\label{pnf overview}

ECM, RCM and LCM suffer from \textit{transitive retry}. Transitive retry is illustrated by the following example:

\textbf{Example 1.} Consider three atomic sections $s_{1}^{x}$, $s_{2}^{y}$, 
and $s_{3}^{z}$ belonging to jobs $\tau_{1}^{x}$,$\tau_{2}^{y}$, 
and $\tau_{3}^{z}$, with priorities $p_{3}^{z}>p_{2}^{y}>p_{1}^{x}$, respectively. 
Assume that $s_{1}^{x}$ and $s_{2}^{y}$ share objects, $s_{2}^{y}$ and $s_{3}^{z}$
share objects. $s_{1}^{x}$ and $s_{3}^{z}$ do not share objects.
$s_{3}^{z}$ can cause $s_{2}^{y}$ to retry, which in turn will cause $s_{1}^{x}$ to retry. 
This means that $s_{1}^{x}$ may retry transitively
because of $s_{3}^{z}$, which will increase the retry cost of $s_{1}^{x}$.

Assume another atomic section $s_4^f$ is introduced. Priority of $s_4^f$ is higher than priority of $s_3^z$. $s_4^f$ shares objects only with $s_3^z$. Thus, $s_4^f$ can make $s_3^z$ to retry, which in turn will make $s_2^y$ to retry, and finally, $s_1^x$ to retry. Thus, transitive retry will move from $s_{4}^{f}$ to $s_{1}^{x}$, increasing the retry cost of $s_{1}^{x}$. 
The situation gets worse as more tasks of higher priorities are added, where each task
shares objects with its immediate lower priority task. $\tau_{3}^{z}$
may have atomic sections that share objects with $\tau_{1}^{x}$,
but this will not prevent the effect of transitive retry due to $s_{1}^{x}$.

Therefore, the analysis in~\cite{stmconcurrencycontrol:emsoft11} and~\cite{lcmdac2012} must extend the set of objects that can cause an atomic section of a lower priority job to retry.  This can be done by initializing the set of conflicting objects, $\gamma_i$, to all objects accessed by all transactions of $\tau_i$. We then cycle through all transactions belonging to all other higher priority tasks. Each transaction $s_j^l$ that accesses at least one of the objects in $\gamma_i$ adds all other objects accessed by $s_j^l$ to $\gamma_i$. The loop over all higher priority tasks is repeated, each time with the new $\gamma_i$, until there are no more transactions accessing any object in $\gamma_i$. The final set of objects(tasks) that can cause transactions in $\tau_i$ to retry is $\theta_i^{ex}(\gamma_i^{ex})$ respectively\footnote{However, note that, this solution may over-extend the set of conflicting objects, and may even contain all objects accessed by all tasks.}. \textit{Priority contention manager with Negative value and First access (PNF)}~\cite{shambake_phd_proposal} is designed to avoid transitive retry. ECM, RCM and LCM suffer from transitive retry. PNF avoids transitive retry by concurrently executing at most $m$ non-conflicting transactions together. These executing transactions are non-preemptive. Thus, executing transactions cannot be aborted due to direct or indirect conflict with other transactions.

The problem with PNF is to know a priori each object accessed by each transaction. This is not suitable with dynamic STM~\cite{Herlihy:2003:STM:872035.872048}. Besides, current implementation of PNF is a centralized CM that uses locks. This increases overhead and wastes reduction in retry cost. PNF is most suitable in case of heavily transitive retry among transactions. In other cases, LCM is preferred.

\subsection{The need for FBLT}
It is required to have a CM that combines benefits of previous CMs. This CM should:
\begin{enumerate}
\item \label{goal 1}reduce retry cost of each transaction $s_i^k$ due to another transaction $s_j^l$ just as LCM does compared to ECM and RCM.
\item \label{goal 2}avoid or bound effect of transitive retry just as PNF without prior knowledge of accessed objects by each transactions. Thus, it maintains semantics of dynamic STM.
\item \label{goal 3}be decentralized and do not use locks. So, overhead is reduced.
\end{enumerate}
FBLT acheives these goals by bounding abortion number of each transaction $s_i^k$ due to other transactions to at most $\delta_i^k$. $\dela_i^k$ includes abort numbers due to direct conflict with other transactions, as well as transitive retry (goal~\ref{goal 2}). If a transaction $s_i^k$ reaches its $\delta_i^k$, it is added to an $m\_$set in FIFO order. In $m\_$set, $s_i^k$ executes non-preemptively. If transactions in $m\_$set conflict together, they use their FIFO order in the $m\_$set to resolve conflict. $s_i^k$ can still abort after it becomes a non-preemptive transaction due to other non-preemptive transactions. The number of abort times for any non-preemptive transactions is bounded by $m-1$ , where $m$ is number of processors, as will be shown in Section~\ref{fblt rc}. So, the key idea is to use the suitable $\delta_i^k$ for each $s_i^k$ before it becomes a non-preemptive transaction. The choice of $\delta_i^k$ should make the total retry cost (thus, schedulability) of any job $\tau_i^x$ under FBLT comparable to the retry cost under ECM, RCM, LCM and PNF. Section~\ref{schedulabiltiy comparison} shows the suitable $\delta_i^k$ for each $s_i^k$ to have equal or better schedulability than other CMs. Preemptive transactions resolve their conflicts using LCM. Thus, FBLT defaults to LCM if abort bounds have not been crossed (goal~\ref{goal 1}). Each non-preemptive transaction, $s_i^k$, uses the time it joined $m\_$set to resolve conflicts with other non-preemptive transactions. So, FBLT does not have to use locks and it is decentralized (goal~\ref{goal 3}).


\section{FBLT}
\label{sec:fblt design}

\begin{algorithm}[h]
\footnotesize{
\LinesNumbered
\KwData{
$s_i^k$: interfered transaction\;
$s_j^l$: interfering transactions\;
$\delta_i^k$: the maximum number of times $s_i^k$ can be aborted during $T_i$\;
$\eta_i^k$: number of times $s_i^k$ has already been aborted up to now\;
$m\_$set: contains at most m non-preemptive transactions. $m$ is number of processors\;
$m\_prio$: priority of any transaction in $m\_$set. $m\_prio$ is higher than any priority of any real-time task\;
$r(s_i^k)$: time point at which $s_i^k$ joined $m\_$set\;
}
\KwResult{atomic sections that will abort}
\uIf{\label{both preemptive}$s_i^k,\,s_j^l \not\in m\_set$}
{
Apply Algorithm~\ref{alg_lcm} (default to LCM)\label{apply lcm}\;
\eIf{\label{preemptive s_i^k aborted}$s_i^k$ is aborted}
{
\eIf{$\eta_i^k<\delta_i^k$}
{
Increment $\eta_i^k$ by 1\label{increment eta 1}\;
}
{
Add $s_i^k$ to $m\_$set\label{add to m_set 1}\;
Record $r(s_i^k)$\label{record 1}\;
Increase priority of $s_i^k$ to $m\_prio$\label{increase priority 1}\;
}
}
{
Swap $s_i^k$ and $s_j^l$\;
Go to Step~\ref{preemptive s_i^k aborted}\;
}
}
\uElseIf{\label{s_j^l is non preemptive}$s_j^l \in m\_set,s_i^k \not\in m\_set$}
{
Abort $s_i^k$\;
\eIf{$\eta_i^k < \delta_i^k$}
{
Increment $\eta_i^k$ by 1\label{increment eta 2}\;
}
{
Add $s_i^k$ to $m\_$set\label{add to m_set 2}\;
Record $r(s_i^k)$\label{record 2}\;
Increase priority of $s_i^k$ to $m\_prio$\label{increase priority 2}\;
}
}
\uElseIf{\label{s_i^k is non-preemptive}$s_i^k \in m\_set,s_j^l \not\in m\_set$}
{
Swap $s_i^k$ and $s_j^l$\;
Go to Step~\ref{s_j^l is non preemptive}\label{end preemptive and non preemptive}\;
}
\Else
{
\label{both non preemptive}
\eIf{$r(s_i^k)<r(s_j^l)$}
{	
Abort $s_j^l$\label{s_i^k first in m_set}\;
}
{
Abort $s_i^k$\label{s_j^l first in m_set}\;
}
}
}
\caption{FBLT}\label{fblt-algorithm}
\end{algorithm}
Algorithm~\ref{fblt-algorithm} shows behaviour of FBLT. Each transaction $s_{i}^{k}$ can be aborted during $T_i$ for at most $\delta_{i}^{k}$ times. $\eta_{i}^{k}$ records number of times $s_{i}^{k}$ has already been aborted up to now. If $s_i^k$ and $s_j^l$ have not joined $m\_$set yet, then they are preemptive transactions. Preemptive transactions resolve conflicts using Algorithm~\ref{alg_lcm} (step~\ref{apply lcm}). So, FBLT defaults to LCM when no transaction reaches its $\delta$. If only one of the transactions is in $m\_$set, then non-preemptive transaction (the one in $m\_$set) aborts the other one (steps~\ref{s_j^l is non preemptive} to~\ref{end preemptive and non preemptive}). $\eta_i^k$ is incremented each time $s_i^k$ is aborted as long as $\eta_i^k < \delta_i^k$ (steps~\ref{increment eta 1} and~\ref{increment eta 2}). Otherwise, $s_i^k$ is added to $m\_$set and its priority is increased to $m\_prio$ (steps~\ref{add to m_set 1} to~\ref{increase priority 1} and~\ref{add to m_set 2} to~\ref{increase priority 2}). When priority of $s_i^k$ is increased to $m\_prio$, $s_i^k$ becomes a non-preemptive transaction. Non-preemptive transactions cannot be aborted by other preemptive transactions, nor by any other real-time job. $m\_$set can hold at most $m$ concurrent transactions because there are $m$ processors in the system. $r(s_i^k)$ records time $s_i^k$ joined $m\_$set (steps~\ref{record 1} and~\ref{record 2}). When non-preemptive transactions conflict together (step~\ref{both non preemptive}), the transaction with smaller $r()$ commits first (steps~\ref{s_i^k first in m_set} and~\ref{s_j^l first in m_set}). Thus, non-preemptive transactions are executed in FIFO order of $m\_$set.

\subsection{Illustrative Example}
FBLT's behaviour is explained by the following example:
\begin{enumerate}
\item Transaction $s_{i}^{k}(\theta_{1},\theta_{2})$ is released while
$m\_set=\emptyset$. $\eta_{i}^{k}=0$ and $\delta_{i}^{k}=3$.
\item \label{fblt_ex_step 2}Transaction $s_{a}^{b}(\theta_{2})$ is released
while $s_{i}^{k}(\theta_{1},\theta_{2})$ is running. $p_{a}^{b}>p_{i}^{k}$
and $\eta_{i}^{k}<\delta_{i}^{k}$. Applying LCM, $s_{i}^{k}(\theta_{1},\theta_{2})$
is aborted in favour of $s_{a}^{b}$ and $\eta_{i}^{k}$ is incremented
to 1.
\item $s_{a}^{b}(\theta_{2})$ commits. $s_{i}^{k}(\theta_{1},\theta_{2})$
runs again. Transaction $s_{c}^{d}(\theta_{2})$ is released while
$s_{i}^{k}(\theta_{1},\theta_{2})$ is running. $p_{c}^{d}>p_{i}^{k}$. Applying LCM, $s_{i}^{k}(\theta_{1},\theta_{2})$ is aborted again in favour of $s_{c}^{d}(\theta_{2})$.
$\eta_{i}^{k}$ is incremented to 2.
\item $s_{c}^{d}(\theta_{2})$ commits. $s_{e}^{f}(\theta_{2},\theta_{3})$
is released. $p_{e}^{f}>p_{i}^{k}$ and $\eta_{e}^{f}=2$. $s_{i}^{k}(\theta_{1},\theta_{2})$
is aborted in favour of $s_{e}^{f}(\theta_{2},\theta_{3})$ and $\eta_{i}^{k}$
is incremented to 3.
\item $s_{j}^{l}(\theta_{3})$ is released. $p_{j}^{l}>p_{e}^{f}$. $s_{e}^{f}(\theta_{2},\theta_{3})$ is aborted in favour of $s_{j}^{l}(\theta_{3})$
and $\eta_{e}^{f}$ is incremented to 1.
\item \label{fblt_ex_step 6}$s_{i}^{k}(\theta_{1},\theta_{2})$ and $s_{e}^{f}(\theta_{2},\theta_{3})$
are compared again. $\because\,\eta_{i}^{k}=\delta_{i}^{k}$, $\therefore\, s_{i}^{k}(\theta_{1},\theta_{2})$
is added to $m\_$set. $m\_set=\left\{ s_{i}^{k}(\theta_{1},\theta_{2})\right\} $.
$s_{i}^{k}(\theta_{1},\theta_{2})$ becomes a non-preemptive transaction.
As $s_{e}^{f}(\theta_{2},\theta_{3})$ is a preemptive transaction, $\therefore\, s_{e}^{f}(\theta_{2},\theta_{3})$ is aborted in
favour of $s_{i}^{k}(\theta_{1},\theta_{2})$ despite $p_{e}^{f}$ is greater than original priority of $s_i^k(\theta_1,\theta_2)$. $\eta_{e}^{f}$ is incremented to 2.
\item \label{fblt_ex_step 7}$s_{j}^{l}(\theta_{3})$ commits but $s_{g}^{h}(\theta_{3})$
is released. $p_{g}^{h}>p_{e}^{f}$ but $\eta_{e}^{f}=\delta_{e}^{f}$.
So, $s_{e}^{f}(\theta_{2},\theta_{3})$ becomes a non-preemptive transaction.
$m\_set=\left\{ s_{i}^{k}(\theta_{1},\theta_{2}),s_{g}^{h}(\theta_{2},\theta_{3})\right\} $.
\item $s_{i}^{k}(\theta_{1},\theta_{2})$ and $s_{g}^{h}(\theta_{2},\theta_{3})$
are now non-preemptive transactions. $s_{i}^{k}(\theta_{1},\theta_{2})$
and $s_{g}^{h}(\theta_{2},\theta_{3})$ still conflict together. So,
they are executed according to their addition order to $m\_$set.
So, $s_{i}^{k}(\theta_{1},\theta_{2})$ commits first, then $s_{g}^{h}(\theta_{2},\theta_{3})$.
\item $s_{g}^{h}(\theta_{3})$ will continue to abort and retry in favour
of $s_{e}^{f}(\theta_{2},\theta_{3})$ until $s_{e}^{f}(\theta_{2},\theta_{3})$
commits or $\eta_{g}^{h}=\delta_{g}^{h}$. Even if $s_{g}^{h}(\theta_{3})$
joined $m\_$set, $s_{g}^{h}(\theta_{3})$ will still abort and retry
in favor of $s_{e}^{f}(\theta_{2},\theta_{3})$ because $s_{e}^{f}(\theta_{2},\theta_{3})$
joined $m\_$set earlier than $s_{g}^{h}(\theta_{3})$.
\end{enumerate}
It is seen from steps \ref{fblt_ex_step 2} to \ref{fblt_ex_step 6}
that $s_{i}^{k}(\theta_{1},\theta_{2})$ can be aborted due to direct
conflict with other transactions, or due to transitive retry. Whatever
the reason of conflict, once a transaction has reached its maximum
allowed $\delta$, the transaction becomes a non-preemptive one
(steps \ref{fblt_ex_step 6} and \ref{fblt_ex_step 7}). Non-preemptive
transactions has higher priority than other preemptive transactions
(steps \ref{fblt_ex_step 6} and \ref{fblt_ex_step 7}). Non-preemptive
transactions execute in their arrival order to $m\_$set.

\section{Retry Cost and Response Time Under FBLT}\label{fblt rc}

We now derive an upper bound on the retry cost of any job $\tau_{i}^{x}$
under FBLT during an interval $L\le T_{i}$. Since all tasks are sporadic
(i.e., each task $\tau_{i}$ has a minimum period $T_{i}$), $T_{i}$
is the maximum study interval for each task $\tau_{i}$.

\begin{clm}

The total retry cost for any job $\tau_{i}^{x}$ under FBLT due to: 1) conflicts
between its transactions and transactions of other jobs during an interval $L\le T_{i}$. 2) release of higher priority jobs, is upper bounded by:

\begin{equation}
RC_{to}(L)\le\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_{i}^{k}len(s_{i}^{k})+\sum_{\forall s_{iz}^k\in \chi_i^k} len(s_{iz}^{k})\right)+RC_{re}(L)\label{eq:fblt_rc}
\end{equation} 
where $\chi_i^k$ is the set of at most $m-1$ maximum length transactions conflicting directly or indirectly (through transitive retry) with $s_i^k$. Each transaction $s_{iz}^k \in \chi_i^k$ belongs to a distinct task $\tau_j$. $RC_{re}(L)$ is the retry cost resulting
from release of higher piority jobs which preempt $\tau_{i}^{x}$.
$RC_{re}(L)$ is calculated by (6.8) in \cite{shambake_phd_proposal}
for G-EDF, and (6.10) in \cite{shambake_phd_proposal} for G-RMA.

\end{clm}

\begin{proof}

By definition of FBLT, $s_{i}^{k}\in\tau_{i}^{x}$ can be aborted
at maximum $\delta_{i}^{k}$ times before $s_{i}^{k}$ joins $m\_$set. Before joining $m\_$set, $s_{i}^{k}$ can be aborted due to higher priority transactions, or transactions
in the $m\_$set. Original priority of transactions in $m\_$set can be of higher or lower priority than
$p_{i}^{x}$. Thus, the maximum time $s_{i}^{k}$ is aborted before
joining $m\_$set occurs if $s_{i}^{k}$ is aborted for $\delta_{i}^{k}$ times. Transactions preceding  $s_i^k$ in $m\_$set can conflict directly with $s_i^k$, or indirectly through transitive retry. The worst case scenario for $s_{i}^{k}$ after joining $m\_$set occurs if $s_{i}^{k}$ is preceded by $m-1$ maximum length conflicting transactions. Hence, in worst case, $s_{i}^{k}$ has to wait for the previous $m-1$ transactions to commit first. Priority of $s_{i}^{k}$ after joining $m\_$set is higher than any real-time job. So, $s_{i}^{k}$ is not aborted
by any job. If $s_{i}^{k}$ has not joined $m\_$set yet, and a higher
priority job $\tau_{j}^{y}$ is released while $s_{i}^{k}$ is running,
then $s_{i}^{k}$ may be aborted if $\tau_{j}^{y}$ has conflicting
transactions with $s_{i}^{k}$. $\tau_{j}^{y}$ causes only one abort
in $\tau_{i}^{x}$ because $\tau_{j}^{y}$ preempts $\tau_{i}^{x}$
only once. If $s_{i}^{k}$ has already joined $m\_$set, then $s_{i}^{k}$
cannot be aborted by release of higher priority jobs. So, the maximum
number of abort times to transactions in $\tau_{i}^{x}$ due to release
of higher priority jobs is less or equal to number of interfering
higher priority jobs to $\tau_{i}^{x}$. Claim follows.

\end{proof}

\begin{clm}

The blocking time for a job $\tau_{i}^{x}$ due to lower priority
jobs is upper bounded by: 
\begin{equation}
D(\tau_{i}^{x})=min\left(max_{1}^{m}(s_{j_{max},\forall\tau_{j}^{l},\, p_{j}^{l}<p_{i}^{x}})\right)\label{eq:fblt_delay}
\end{equation}
where $s_{j_{max}}$ is the maximum length transaction in any job
$\tau_{j}^{l}$ with original priority lower than $p_{i}^{x}$. The
right hand side of (\ref{eq:fblt_delay}) is the minimum of the $m$
maximum transactional lengths in all jobs with lower priority than
$\tau_{i}^{x}$.

\end{clm}

\begin{proof}

$\tau_{i}^{x}$ is blocked when it is initially released and all processors
are busy with lower priority jobs with non-preemptive transactions.
Although $\tau_{i}^{x}$ can be preempted by higher priority jobs,
$\tau_{i}^{x}$ cannot be blocked after it is released. If $\tau_{i}^{x}$
is preempted by a higher priority job $\tau_{j}^{y}$, then $\tau_{j}^{y}$
finishes execution, the underlying scheduler will not choose a lower
priority job than $\tau_{i}^{x}$ before $\tau_{i}^{x}$. So, after
$\tau_{i}^{x}$ is released, there is no chance for any transaction
$s_{u}^{v}$ belonging to a lower priority job than $\tau_{i}^{x}$
to run before $\tau_{i}^{x}$. Thus, $s_{u}^{v}$ cannot join $m\_$set
before $\tau_{i}^{x}$ finishes. Consequently, the worst case blocking
time for $\tau_{i}^{x}$ occurs when the maximum length $m$ transactions
in lower priority jobs than $\tau_{i}^{x}$ are executing non-preemptively.
After the minimum length transaction in the $m\_$set finishes, the
underlying scheduler will choose $\tau_{i}^{x}$ or a higher priority
job to run. Claim follows.

\end{proof}

\begin{clm}

Response time of any job $\tau_{i}^{x}$ during an interval $L\le T_{i}$
under FBLT is upper bounded by 
\begin{equation}
R_{i}^{up}=c_{i}+RC_{to}(L)+D(\tau_{i}^{x})+\left\lfloor \frac{1}{m}\sum_{\forall j\ne i}W_{ij}(R_{i}^{up})\right\rfloor \label{eq:fblt_res_time}
\end{equation}
where $RC_{to}(L)$ is calculated by (\ref{eq:fblt_rc}), $D(\tau_{i}^{x})$
is calculated by by (\ref{eq:fblt_delay}), and $W_{ij}(R_{i}^{up})$
is calculated by (11) in \cite{stmconcurrencycontrol:emsoft11} for
G-EDF, and (17) in \cite{stmconcurrencycontrol:emsoft11} for G-RMA.
(11) and (17) in \cite{stmconcurrencycontrol:emsoft11} inflates $c_{j}$
of any job $\tau_{j}^y\ne\tau_{i}^x,\, p_{j}^y>p_{i}^x$ by retry cost
of transactions in $\tau_{j}^y$.

\end{clm}

\begin{proof}

Response time of any job $\tau_i^x$ is calculated directly from FBLT's behaviour. Response time of any job $\tau_{i}^{x}$ is the sum of its
worst case execution time $c_{i}$, plus retry cost of transactions
in $\tau_{i}^{x}$ ($RC_{to}(L)$), plus blocking time of $\tau_{i}^{x}$
($D(\tau_{i}^{x})$), and the workload interference of higher priority
jobs. Workload interfernence of higher priority jobs scheduled by
G-EDF is calculated by (11) in \cite{stmconcurrencycontrol:emsoft11},
and by (17) in \cite{stmconcurrencycontrol:emsoft11} for G-RMA. Claim follows.

\end{proof}


\section{FBLT vs. Other Synchronization Techniques}\label{schedulabiltiy comparison}

We now (formally) compare the schedulability of G-EDF (G-RMA) with FBLT against ECM, RCM, LCM, PNF and lock-free synchronization~\cite{stmconcurrencycontrol:emsoft11,lcmdac2012,key-5,shambake_phd_proposal}. 
Such a comparison will reveal when FBLT outperforms  others. Toward this, we compare the total utilization under G-EDF (G-RMA)/FBLT,  with that under the other synchronization methods.
Inflated execution time of each method, which is the sum of the worst-case execution time of the task and its retry cost, is used in the utilization calculation of each task.

No processor is available for $\tau_i^x$ during the blocking time. As each processor is busy with some job other than $\tau_i^x$, $D(\tau_i^x)$ is not added to the inflated execution time of $\tau_i^x$. Hence, $D(\tau_i^x)$ is not added to the utilization calculation of $\tau_i^x$.

Let $RC_{A}(T_{i})$ denote the retry cost of any $\tau_{i}^{x}$
using the synchronization method $A$ during $T_{i}$. Let $RC_{B}(T_{i})$
denote the retry cost of any $\tau_{i}^{x}$ using synchronization
method $B$ during $T_{i}$. Then, schedulability of $A$ is comparable
to $B$ if 
\begin{eqnarray}
\sum_{\forall\tau_{i}}\frac{c_{i}+RC_{A}(T_{i})}{T_{i}} & \le & \sum_{\forall\tau_{i}}\frac{c_{i}+RC_{B}(T_{i})}{T_{i}}\nonumber \\
\sum_{\forall\tau_{i}}\frac{RC_{A}(T_{i})}{T_{i}} & \le & \sum_{\forall\tau_{i}}\frac{RC_{B}(T_{i})}{T_{i}}\label{eq:utilization comparison}
\end{eqnarray}



\subsection{FBLT vs. ECM}
\label{sec:fblt vs ecm}

\begin{clm}\label{clm:fblt_ecm}

Schedulability of FBLT is equal or better to ECM's when maximum abort number of any preemptive transaction $s_i^k$ is less or equal to number of direct conflicting transactions with $s_i^k$ in all other jobs with higher priority than priority of current job of $\tau_{i}$.

\end{clm}

\begin{proof}

By substituing $RC_{A}(T_{i})$ and $RC_{B}(T_{i})$ in (\ref{eq:utilization comparison})
with (\ref{eq:fblt_rc}) and (6.7) in \cite{shambake_phd_proposal}
respectively. 

\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_{i}^{k}len(s_{i}^{k})+\sum_{s_{iz}^k\in \chi_i^k} len(s_{iz}^{k})\right)+RC_{re}(T_{i})}{T_{i}}\label{eq:fblt_edf_comparison_1}\\
\le & \sum_{\forall\tau_{i}}\frac{\left(\sum_{\forall\tau_{j}\in\gamma_{i}^{ex}}\sum_{\theta\in\theta_{i}^{ex}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil \sum_{\forall\bar{s_{j}^{h}}(\theta)}len\left(\bar{s_{j}^{h}}(\theta)+s_{max}^{j}(\theta)\right)\right)\right)+RC_{re}(T_{i})}{T_{i}}\nonumber 
\end{eqnarray}


Let $\theta_{i}^{ex}=\theta_{i}+\theta_{i}^{*}$ where $\theta_{i}^{*}$
is the set of objects not accessed directly by $\tau_{i}$ but can
enforce transactions in $\tau_{i}$ to retry due to transitive retry.
Let $\gamma_{i}^{ex}=\gamma_{i}+\gamma_{i}^{*}$ where $\gamma_{i}^{*}$
is the set of tasks that access objects in $\theta_{i}^{*}$. $\bar{s_{j}^{h}}(\theta)$
can access multiple objects, so $s_{max}^{j}(\theta)$ is the maximum
length transaction conflicting with $\bar{s_{j}^{h}}(\theta)$. $\bar{s_{j}^{h}}(\theta)$ is included only once for all $\theta \in \Theta_j^h$. Each $\theta \in \theta_i^{ex}$ has its own $s_{max}^j(\theta)$. But $s_i^h$ can access multiple objects denoted as $\Theta_j^h$. So, $s_{max}^j(\theta)$ is replaced by $s_{max}^j(\Theta_j^h)$ where $s_{max}^j(\Theta_j^h)=max\{s_{max}^j(\theta),\forall \theta \in \Theta_j^h\}$
 $s_{max}^j(\Theta_j^h)$ is included once for each $\theta \in \theta_i$. Each $\tau_i^x$ has the same interference pattern from higher priority jobs, $\tau_j^h$, under FBLT and ECM. Hence, $RC_{re}(T_i)$ for $\tau_i^x$ is the same under FBLT and ECM. Consequently, (\ref{eq:fblt_edf_comparison_1})
becomes 
\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_{i}^{k}len(s_{i}^{k})+\sum_{s_{iz}^k\in \chi_i^k} len(s_{iz}^{k})\right)}{T_{i}}\label{eq:fblt_edf_comparison_3}\\
\le & \sum_{\forall\tau_{i}}\frac{\left(\sum_{\forall\tau_{j}\in\gamma_{i}^{ex}}\sum_{\forall \bar{s_{j}^{h}}(\Theta_j^h),\,\Theta_j^h\in\theta_{i}^{ex}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil len\left(\bar{s_{j}^{h}}(\Theta_j^h)+s_{max}^{j}(\Theta_j^h)\right)\right)\right)}{T_{i}}\nonumber 
\end{eqnarray}
Although different $s_{i}^{k}$ can have common conflicting transactions
$\bar{s_{j}^{h}}$, but no more than one $s_{i}^{k}$ can be preceded
by the same $\bar{s_{j}^{h}}$ in the $m\_$set. This happens because
transactions in the $m\_$set are non-preemptive. Original priority
of transactions preceding $s_{i}^{k}$ in the $m\_$set can be of
lower or higher priority than original priority of $s_{i}^{k}$. Under
G-EDF, $\tau_{j}$ can have at least one job of higher
priority than $\tau_{i}^{x}$, then $\left\lceil \frac{T_{i}}{T_{j}}\right\rceil \ge1$.
So, each one of the $s_{iz}^{k}$ in the left hand side of (\ref{eq:fblt_edf_comparison_3})
is included in one of the $\bar{s_{j}^{h}}(\theta)$ in the right hand
side of (\ref{eq:fblt_edf_comparison_3}). Then (\ref{eq:fblt_edf_comparison_3})
holds if 
\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\delta_i^klen(s_{i}^{k})}{T_{i}}\label{eq:fblt_edf_comparison_4}\\
\le &
\sum_{\forall\tau_{i}}\frac{\sum_{\forall\tau_{j}\in\gamma_{i}^{ex}}\sum_{\forall \bar{s_{j}^{h}}(\Theta_j^h),\,\Theta_j^h\in\theta_{i}^{ex}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil len\left(s_{max}^{j}(\Theta_j^h)\right)\right)}{T_{i}}\nonumber 
\end{eqnarray}

As FBLT is required to bound effect of transitive retry, only $\theta_i$ (not the whole $\theta_i^{ex}$) will be considered in (\ref{eq:fblt_edf_comparison_4}). Thus, ECM acts as if there were no transitive retry. Consequently, (\ref{eq:fblt_edf_comparison_4}) holds if  

\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\delta_i^klen(s_{i}^{k})}{T_{i}}\label{eq:fblt_edf_comparison_4_1}\\
\le &
\sum_{\forall\tau_{i}}\frac{\sum_{\forall\tau_{j}\in\gamma_{i}}\sum_{\forall \bar{s_{j}^{h}}(\Theta),\,\Theta\in(\theta_{i}\cap\Theta_j^h)}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil len\left(s_{max}^{j}(\Theta)\right)\right)}{T_{i}}\nonumber 
\end{eqnarray}

where $s_{max}^j(\Theta) \le s_{max}^j(\Theta_j^h)$. For each $s_{i}^{k}\in s_{i}$, there are a set of zero or more $\bar{s_{j}^{h}}(\Theta)\in\tau_{j},\,\forall\tau_{j}\ne\tau_{i}$
that are conflicting with $s_{i}^{k}$. Assuming this set of conflicting
transactions with $s_{i}^{k}$ is denoted as $\eta_{i}^{k}=\left\{ \bar{s_{j}^{h}}(\Theta)\in\tau_{j}:\left(\Theta\in\(\theta_{i}\cap\Theta_j^h)\right)\wedge\left(\forall\tau_{j}\ne\tau_{i}\right)\wedge\left(\bar{s_{j}^{h}}(\Theta)\not\in\eta_{i}^{l},\, l\ne k\right)\right\} $.
The last condition $\bar{s_{j}^{h}}(\Theta)\not\in\eta_{i}^{l},\, l\ne k$
in definition of $\eta_{i}^{k}$ ensures that common transactions $\bar{s_{j}^{h}}$
that can conflict with more than one transaction $s_{i}^{k}\in\tau_{i}$
are split among different $\eta_{i}^{k},\, k=1,..,|s_{i}|$. This
condition is necessary because in ECM, no two or more transactions
of $\tau_{i}^{x}$ can be aborted by the same transaction of $\tau_{j}^{h}$
where $p_{j}^{h}>p_{i}^{x}$. By substitution of $\eta_{i}^{k}$ in
(\ref{eq:fblt_edf_comparison_4_1}), we get 
\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\delta_i^klen(s_{i}^{k})}{T_{i}}\label{eq:fblt_edf_comparison_5}\\
\le & \sum_{\forall\tau_{i}}\frac{\left(\sum_{\forall k=1}^{|s_{i}|}\sum_{\bar{s_{j}^{h}}(\Theta)\in\eta_{i}^{k}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil len\left(s_{max}^{j}(\Theta)\right)\right)\right)}{T_{i}}\nonumber 
\end{eqnarray}

(\ref{eq:fblt_edf_comparison_5}) holds if for each $s_{i}^{k}\in\tau_{i}$
\begin{equation}
\delta_{i}^{k}\le\frac{\sum_{\bar{s_{j}^{h}}(\Theta)\in\eta_{i}^{k}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil len\left(s_{max}^{j}(\Theta)\right)\right)}{len(s_{i}^{k})}\label{eq:fblt_edf_comparison_6}
\end{equation}

As $len\left(s_{max}^{j}(\Theta)\right)\ge len(s_{i}^{k})$, then (\ref{eq:fblt_edf_comparison_6}) holds if $\delta_{i}^{k}\le \sum_{\bar{s_{j}^{h}}(\Theta)\in\eta_{i}^{k}}\left\lceil \frac{T_{i}}{T_{j}}\right\rceil$

$\sum_{\bar{s_{j}^{h}}(\Theta)\in\eta_{i}^{k}}\left\lceil \frac{T_{i}}{T_{j}}\right\rceil$
is the maximum number of directly conflicting transactions with $s_i^k$ in all jobs with higher priority than $\p_{i}^x$. Claim follows.

\end{proof}

\subsection{FBLT vs. RCM}
\label{sec:fblt vs rcm}

\begin{clm}\label{clm:fblt_rcm}

Schedulability of FBLT is equal or better to RCM's when maximum abort number
of any preemptive transaction $s_{i}^{k}$ is less or equal to number of directly conflicting transactions with $s_{i}^{k}$ in all jobs with higher priority than $\tau_{i}$ minus sum of maximum $m-1$ transactional lengths in all tasks.

\end{clm}

\begin{proof}

By substituing $RC_{A}(T_{i})$ and $RC_{B}(T_{i})$ in (\ref{eq:utilization comparison})
with (\ref{eq:fblt_rc}) and (6.9) in \cite{shambake_phd_proposal}
respectively. 

\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_i^klen(s_{i}^{k})+\sum_{s_{iz}^k\in \chi_i^k} len(s_{iz}^{k})\right)+RC_{re}(T_{i})}{T_{i}}\label{eq:fblt_rcm_comparison_1}\\
\le & \sum_{\forall\tau_{i}}\frac{\left(\sum_{\forall\tau_{j}^{*}\in\gamma_{i}^{ex}}\sum_{\forall\theta\in\theta_{i}^{ex}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)\sum_{\forall\bar{s_{j}^{h}(\theta)}}len\left(\bar{s_{j}^{h}(\theta)}+s_{max}^{j}(\theta)\right)\right)+RC_{re}(T_{i})}{T_{i}}\nonumber 
\end{eqnarray}
where $\tau_{j}^{*}=\left\{ \tau_{j}:\left(\tau_{j}\ne\tau_{i}\right)\wedge\left(p_{j}>p_{i}\right)\right\} $.
Let $\theta_{i}^{ex}=\theta_{i}+\theta_{i}^{*}$ where $\theta_{i}^{*}$
is the set of objects not accessed directly by $\tau_{i}$ but can
enforce transactions in $\tau_{i}$ to retry due to transitive retry.
Let $\gamma_{i}^{ex}=\gamma_{i}+\gamma_{i}^{*}$ where $\gamma_{i}^{*}$
is the set of tasks that access objects in $\theta_{i}^{*}$. $\bar{s_{j}^{h}}(\theta)$
can access multiple objects, so $s_{max}^{j}(\theta)$ is the maximum
length transaction conflicting with $\bar{s_{j}^{h}}(\theta)$. $\bar{s_{j}^{h}}(\theta)$ is included only once for all $\theta \in \Theta_j^h$. Each $\theta \in \theta_i^{ex}$ has its own $s_{max}^j(\theta)$. But $s_i^h$ can access multiple objects denoted as $\Theta_j^h$. So, $s_{max}^j(\theta)$ is replaced by $s_{max}^j(\Theta_j^h)$ where $s_{max}^j(\Theta_j^h)=max\{s_{max}^j(\theta),\forall \theta \in \Theta_j^h\}$. $s_{max}^j(\Theta_j^h)$ is included once for each $\theta \in \theta_i$. Each $\tau_i^x$ has the same interference pattern from higher priority jobs, $\tau_j^h$, under FBLT and RCM. Hence, $RC_{re}(T_i)$ for $\tau_i^x$ is the same under FBLT and RCM. Consequently, (\ref{eq:fblt_rcm_comparison_1}) becomes 
\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_i^klen(s_{i}^{k})+\sum_{s_{iz}^k\in \chi_i^k} len(s_{iz}^{k})\right)}{T_{i}}\label{eq:fblt_rcm_comparison_2}\\
\le & \sum_{\forall\tau_{i}}\frac{\sum_{\forall\tau_{j}^{*}\in\gamma_{i}^{ex}}\sum_{\forall \bar{s_j^h}(\Theta_j^h),\Theta_j^h \in\theta_{i}^{ex}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)len\left(\bar{s_{j}^{h}}(\Theta_j^h)+s_{max}^{j}(\Theta_j^h)\right)}{T_{i}}\nonumber 
\end{eqnarray}

Although different $s_{i}^{k}$ can have common conflicting transactions
$\bar{s_{j}^{h}}$, but no more than one $s_{i}^{k}$ can be preceded
by the same $\bar{s_{j}^{h}}$ in the $m\_$set. This happens because
transactions in the $m\_$set are non-preemptive. Original priority
of transactions preceding $s_{i}^{k}$ in the $m\_$set can be of
lower or higher priority than original priority of $s_{i}^{k}$. Under
G-RMA, $p_{j}>p_{i}$ means that $T_{j}\le T_{i}$, then $\left\lceil \frac{T_{i}}{T_{j}}\right\rceil \ge1$.
For each $s_{i}^{k}\in s_{i}$, there are a set of zero or more $\bar{s_{j}^{h}}(\Theta_j^h)\in\tau_{j}^{*}$
that are conflicting with $s_{i}^{k}$. Assuming this set of conflicting
transactions with $s_{i}^{k}$ is denoted as $\eta_{i}^{k}=\left\{ \bar{s_{j}^{h}}(\Theta_j^h)\in\tau_{j}^{*}:\left(\Theta_j^h\in\theta_{i}^{ex}\right)\wedge\left(\bar{s_{j}^{h}}(\Theta_j^h)\not\in\eta_{i}^{l},\, l\ne k\right)\right\} $.
The last condition $\bar{s_{j}^{h}}(\theta)\not\in\eta_{i}^{l},\, l\ne k$
in definition of $\eta_{i}^{k}$ ensures that common transactions $\bar{s_{j}^{h}}$
that can conflict with more than one transaction $s_{i}^{k}\in\tau_{i}$
are split among different $\eta_{i}^{k},\, k=1,..,|s_{i}|$. This
condition is necessary because in RCM, no two or more transactions
of $\tau_{i}^{x}$ can be aborted by the same transaction of $\tau_{j}^{h}$
where $p_{j}^{h}>p_{i}^{x}$. By substitution of $\eta_{i}^{k}$ in
(\ref{eq:fblt_rcm_comparison_2}), we get 
\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_i^klen(s_{i}^{k})+\sum_{s_{iz}^k\in \chi_i^k} len(s_{iz}^{k})\right)}{T_{i}}\label{eq:fblt_rcm_comparison_4}\\
\le & \sum_{\forall\tau_{i}}\frac{\left(\sum_{\forall k=1}^{|s_{i}|}\sum_{\bar{s_{j}^{h}}(\Theta_j^h)\in\eta_{i}^{k}}\left(\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)len\left(\bar{s_{j}^{h}}(\Theta_j^h)+s_{max}^{j}(\Theta_j^h)\right)\right)\right)}{T_{i}}\nonumber 
\end{eqnarray}


$\bar{s_{j}^{h}}$ belongs to higher priority jobs than $\tau_{i}$. $s_{max}^{j}$ belongs to higher priority jobs than $\tau_{i}$ or $\tau_{i}$ itself. $s_{max}^{j}$ has a lower priority than $\tau_j$. Transactions in $m\_$set can belong to jobs
with original priority higher or lower than $\tau_{i}$. So, (\ref{eq:fblt_rcm_comparison_4})
holds if for each $s_{i}^{k}\in\tau_{i}$ 
\begin{equation}
\delta_i^klen(s_{i}^{k})\le\left(\sum_{\bar{s_{j}^{h}}(\Theta_j^h)\in\eta_{i}^{k}}\left(\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)len\left(\bar{s_{j}^{h}}(\Theta_j^h)+s_{max}^{j}(\Theta_j^h)\right)\right)\right)-\sum_{s_{iz}^k\in \chi_i^k} len(s_{iz}^{k})\label{eq:fblt_rcm_comparison_5}
\end{equation}
Then
\begin{equation}
\delta_i^k\le\left(\sum_{\bar{s_{j}^{h}}(\Theta_j^h)\in\eta_{i}^{k}}\left(\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)len\left(\frac{\bar{s_{j}^{h}}(\Theta_j^h)+s_{max}^{j}(\Theta_j^h)}{s_{i}^{k}}\right)\right)\right)-\sum_{s_{iz}^k \in \chi_i^k} len\left(\frac{s_{iz}^{k}}{s_{i}^{k}}\right)\label{eq:fblt_rcm_comparison_14}
\end{equation}

Let $\epsilon=\left\{s_{u_{max}}:(1\le u \le n)\wedge \left(s_{u1_{max}} \ge s_{u2_{max}},\,u1 < u2 \right)\right\}$, where $n$ is number of tasks, and $s_{u_{max}}$ is maximum transactional length in any job of $\tau_u$. Thus, $\epsilon$ is the set of maximum transactional lengths of all task in non-increasing order. Each $s_{u_{max}} \in \epsilon$ belongs to a distinct task. Thus, $\sum_{s_{iz}^{k} \in \chi_i^k}len\left(\frac{s_{iz}^{k}}{s_{i}^{k}}\right)\le \sum_{u=1,\,s_{u_{max}}\in \epsilon}^{min(n,m)-1} s_{u_{max}}$. $\sum_{u=1,\,s_{u_{max}}\in \epsilon}^{min(n,m)-1} s_{u_{max}}$ is the sum of at most maximum $m-1$ transactional lengths of all tasks. $|\chi_i^k|\le m-1$ and $len(s_{max}^{j}(\Theta_j^h)) \ge len(s_{i}^{k})$. So, (\ref{eq:fblt_rcm_comparison_14})
holds if 
\begin{equation}
\delta_i^k\le\left(\sum_{\bar{s_{j}^{h}}(\Theta_j^h)\in\eta_{i}^{k}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)\right)-\sum_{u=1,\,s_{u_{max}}\in \epsilon}^{min(n,m)-1} s_{u_{max}} \right)\label{eq:fblt_rcm_comparison_15}
\end{equation}

To bound effect of transitive retry, only objects that belong to $\theta_i$ (not whole $\theta_i^{ex}$) will be considered. So, RCM acts as if there were no transitive retry.  Thus, $\eta_i^k$ is modified to $\bar{\eta_i^k}=\left\{ \bar{s_{j}^{h}}(\Theta)\in\tau_{j}^{*}:\left(\Theta \in \Theta_j^h \cap \theta_{i}\right)\wedge\left(\bar{s_{j}^{h}}(\Theta)\not\in\eta_{i}^{l},\, l\ne k\right)\right\}$. As $\bar{\eta_i^k} \subseteq \eta_i^k$, then (\ref{eq:fblt_rcm_comparison_15}) still holds if $\eta_i^k$ is replaced with $\bar{\eta_i^k}$.  Consequently, (\ref{eq:fblt_rcm_comparison_15}) holds if 
\begin{equation}
\delta_i^k\le\left(\sum_{\bar{s_{j}^{h}}(\Theta)\in\bar{\eta_{i}^{k}}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)\right)-\sum_{u=1,\,s_{u_{max}}\in \epsilon}^{min(n,m)-1} s_{u_{max}} \right) \right)\label{eq:fblt_rcm_comparison_16}
\end{equation}

$\sum_{\bar{s_{j}^{h}}(\Theta)\in \bar{\eta_{i}^{k}}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)$
represents number of directly conflicting transactions with $s_{i}^{k}$ in
all jobs with higher priority than $\tau_{i}$. Claim follows.

\end{proof}

\subsection{FBLT vs. G-EDF/LCM}
\label{sec:fblt vs gedf lcm}

\begin{clm}\label{clm:fblt_lcm_edf}

Schedulability of FBLT is equal or better to G-EDF/LCM's when maximum
abort number of each preemptive transaction $s_{i}^{k}$ is less or equal to sum of total number each transaction
$s_{j}^{h}$ can directly conflict with $s_{i}^{k}$ multiplied by maximum
$\alpha$ with which $s_{j}^{h}$ can conflict with maximum length
transaction sharing objects with $s_{i}^{k}$ and $s_{j}^{h}$.

\end{clm}

\begin{proof}

By substituting $RC_{A}(T_{i})$ and $RC_{B}(T_{i})$ in (\ref{eq:utilization comparison})
with (\ref{eq:fblt_rc}) and (6.7) in \cite{shambake_phd_proposal}
respectively. 

\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_i^klen(s_{i}^{k})+\sum_{\forall s_{iz}^{k}\in\chi_{i}^{k}}len(s_{iz}^{k})\right)+RC_{re}(T_{i})}{T_{i}}\label{eq:fblt_lcm_edf_comparison_1}\\
\le & \sum_{\forall\tau_{i}}\frac{\left(\sum_{\forall\tau_{j}\in\gamma_{i}^{ex}}\sum_{\theta\in\theta_{i}^{ex}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil \sum_{\forall\bar{s_{j}^{h}(\theta)}}len\left(\bar{s_{j}^{h}(\theta)}+\bar{\alpha_{max}^{jh}}s_{max}^{j}(\theta)\right)\right)\right)}{T_{i}}\nonumber \\
+ & \sum_{\forall\tau_{i}}\frac{\left(\sum_{\forall s_{i}^{k}}\left(1-\alpha_{max}^{ik}\right)len\left(s_{max}^{i}\right)\right)+RC_{re}(T_{i})}{T_{i}}\nonumber 
\end{eqnarray}
Let $\theta_{i}^{ex}=\theta_{i}+\theta_{i}^{*}$ where $\theta_{i}^{*}$
is the set of objects not accessed directly by $\tau_{i}$ but can
enforce transactions in $\tau_{i}$ to retry due to transitive retry.
Let $\gamma_{i}^{ex}=\gamma_{i}+\gamma_{i}^{*}$ where $\gamma_{i}^{*}$
is the set of tasks that access objects in $\theta_{i}^{*}$. $\bar{s_{j}^{h}}(\theta)$
can access multiple objects, so $s_{max}^{j}(\theta)$ is the maximum
length transaction conflicting with $\bar{s_{j}^{h}}(\theta)$. $\bar{s_{j}^{h}}(\theta)$ is included only once for all $\theta \in \Theta_j^h$. Each $\theta \in \theta_i^{ex}$ has its own $s_{max}^j(\theta)$. But $s_i^h$ can access multiple objects denoted as $\Theta_j^h$. So, $s_{max}^j(\theta)$ is replaced by $s_{max}^j(\Theta_j^h)$ where $s_{max}^j(\Theta_j^h)=max\{s_{max}^j(\theta),\forall \theta \in \Theta_j^h\}$
 $s_{max}^j(\Theta_j^h)$ is included once for each $\theta \in \theta_i$. Each $\tau_i^x$ has the same interference pattern from higher priority jobs, $\tau_j^h$, under FBLT and G-EDF/LCM. Hence, $RC_{re}(T_i)$ for $\tau_i^x$ is the same under FBLT and G-EDF/LCM. Consequently, (\ref{eq:fblt_lcm_edf_comparison_1})
holds if 
\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_i^klen(s_{i}^{k})+\sum_{\forall s_{iz}^{k}\in\chi_{i}^{k}}len(s_{iz}^{k})\right)}{T_{i}}\label{eq:fblt_lcm_edf_comparison_2}\\
\le & \sum_{\forall\tau_{i}}\frac{\left(\sum_{\forall\tau_{j}\in\gamma_{i}^{ex}}\sum_{\forall s_i^h(\Theta_j^h),\,\Theta_j^h\in
\theta_{i}^{ex}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil len\left(\bar{s_{j}^{h}}(\Theta_j^h)+\bar{\alpha_{max}^{jh}}s_{max}^{j}(\Theta_j^h)\right)\right)\right)}{T_{i}}\nonumber \\
+ & \sum_{\forall\tau_{i}}\frac{\left(\sum_{\forall s_{i}^{k}}\left(1-\alpha_{max}^{ik}\right)len\left(s_{max}^{i}\right)\right)}{T_{i}}\nonumber 
\end{eqnarray}

Although different $s_{i}^{k}$ can have common conflicting transactions
$\bar{s_{j}^{h}}$, but no more than one $s_{i}^{k}$ can be preceded
by the same $\bar{s_{j}^{h}}$ in the $m\_$set. This happens because
transactions in the $m\_$set are non-preemptive. Original priority
of transactions preceding $s_{i}^{k}$ in the $m\_$set can be of
lower or higher priority than original priority of $s_{i}^{k}$. Under
G-EDF/LCM, $\tau_{j}\ne\tau_{i}$ can have at least one job of higher
priority than current job of $\tau_{i}$, then $\left\lceil \frac{T_{i}}{T_{j}}\right\rceil \ge1$.
So, each one of the $s_{iz}^{k}$ in the left hand side of (\ref{eq:fblt_lcm_edf_comparison_2})
is included in one of the $\bar{s_{j}^{h}}(\Theta_j^h)$ in the right
hand side of (\ref{eq:fblt_lcm_edf_comparison_2}). Then, (\ref{eq:fblt_lcm_edf_comparison_2}) holds if 
\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\delta_i^klen(s_{i}^{k})}{T_{i}}\label{eq:fblt_lcm_edf_comparison_4}\\
\le & \sum_{\forall\tau_{i}}\frac{\left(\sum_{\forall\tau_{j}\in\gamma_{i}^{ex}}\sum_{\forall\bar{s_{j}^{h}}(\Theta_j^h),\Theta_j^h\in\theta_{i}^{ex}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil len\left(\bar{\alpha_{max}^{jh}}s_{max}^{j}(\Theta_j^h)\right)\right)\right)}{T_{i}}\nonumber \\
+ & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}}\left(1-\alpha_{max}^{ik}\right)len\left(s_{max}^{i}\right)}{T_{i}}\nonumber 
\end{eqnarray}

To bound effect of transitive retry, only $\theta_i$ (not the whole $\theta_i^{ex}$) will be considered in (\ref{eq:fblt_lcm_edf_comparison_4}). So, G-EDF/LCM acts as if there is no transitive retry. Consequently, (\ref{eq:fblt_lcm_edf_comparison_4}) holds if 

\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\delta_i^klen(s_{i}^{k})}{T_{i}}\label{eq:fblt_lcm_edf_comparison_4_1}\\
\le & \sum_{\forall\tau_{i}}\frac{\left(\sum_{\forall\tau_{j}\in\gamma_{i}^}\sum_{\forall\bar{s_{j}^{h}}(\Theta),\Theta \in \Theta_j^h \cap \theta_{i}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil len\left(\bar{\alpha_{max}^{jh}}s_{max}^{j}(\Theta)\right)\right)\right)}{T_{i}}\nonumber \\
+ & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}}\left(1-\alpha_{max}^{ik}\right)len\left(s_{max}^{i}\right)}{T_{i}}\nonumber 
\end{eqnarray}

where $s_{max}^j(\Theta) \le s_{max}^j(\Theta_j^h)$. For each $s_{i}^{k}\in s_{i}$, there are a set of zero or more $\bar{s_{j}^{h}}(\Theta_j^h)\in\tau_{j},\,\forall\tau_{j}\ne\tau_{i}$
that are conflicting with $s_{i}^{k}$. Assuming this set of conflicting
transactions with $s_{i}^{k}$ is denoted as $\eta_{i}^{k}=\left\{ \bar{s_{j}^{h}}(\Theta)\in\tau_{j}:\left(\Theta\in\theta_{i} \cap \Theta_j^h \right)\wedge\left(\forall\tau_{j}\ne\tau_{i}\right)\wedge\left(\bar{s_{j}^{h}}(\theta)\not\in\eta_{i}^{l},\, l\ne k\right)\right\} $.
The last condition $\bar{s_{j}^{h}}(\theta)\not\in\eta_{i}^{l},\, l\ne k$
in definition of $\eta_{i}^{k}$ ensures that common transactions
$\bar{s_{j}^{h}}$ that can conflict with more than one transaction
$s_{i}^{k}\in\tau_{i}$ are split among different $\eta_{i}^{k},\, k=1,..,|s_{i}|$.
This condition is necessary because in G-EDF/LCM, no two or more transactions
of $\tau_{i}^{x}$ can be aborted by the same transaction of $\tau_{j}^{h}$
where $p_{j}^{h}>p_{i}^{x}$. By substitution of $\eta_{i}^{k}$ in
(\ref{eq:fblt_lcm_edf_comparison_4}), we get 
\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\delta_i^klen(s_{i}^{k})}{T_{i}}\label{eq:fblt_lcm_edf_comparison_5}\\
\le & \sum_{\forall\tau_{i}}\frac{\sum_{k=1}^{|s_{i}|}\sum_{\forall\bar{s_{j}^{h}}(\Theta)\in\eta_{i}^{k}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil len\left(\bar{\alpha_{max}^{jh}}s_{max}^{j}(\Theta)\right)\right)}{T_{i}}\nonumber \\
+ & \sum_{\forall\tau_{i}}\frac{\left(\sum_{\forall s_{i}^{k}}\left(1-\alpha_{max}^{ik}\right)len\left(s_{max}^{i}\right)\right)}{T_{i}}\nonumber 
\end{eqnarray}
$\bar{s_{j}^{h}}$ belongs to higher priority jobs than $\tau_{i}$
and $s_{max}^{j}$ belongs to higher priority jobs than $\tau_{i}$
or $\tau_{i}$ itself. Transactions in $m\_$set can belong to jobs
with original priority higher or lower than $\tau_{i}$. So, (\ref{eq:fblt_lcm_edf_comparison_5})
holds if for each $s_{i}^{k}\in\tau_{i}$ 
\[
\delta_i^klen(s_{i}^{k})\le\left(\sum_{\forall\bar{s_{j}^{h}}(\Theta)\in\eta_{i}^{k}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil \right)len\left(\bar{\alpha_{max}^{jh}}s_{max}^{j}(\Theta)\right)\right)+\left(1-\alpha_{max}^{ik}\right)len\left(s_{max}^{i}\right)
\]
Then
\begin{equation}
\delta_i^k\le\left(\sum_{\forall\bar{s_{j}^{h}}(\Theta)\in\eta_{i}^{k}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil \right)len\left(\frac{\bar{\alpha_{max}^{jh}}s_{max}^{j}(\Theta)}{s_{i}^{k}}\right)\right)+\left(1-\alpha_{max}^{ik}\right)len\left(\frac{s_{max}^{i}}{s_{i}^{k}}\right)\label{eq:fblt_lcm_edf_comparison_6}
\end{equation}
As $len\left(\frac{s_{max}^{j}(\Theta)}{s_{i}^{k}}\right)\ge1$, then (\ref{eq:fblt_lcm_edf_comparison_6}) holds if 
\begin{equation*}
\delta_i^k\le\left(\sum_{\bar{s_{j}^{h}}(\Theta)\in\eta_{i}^{k}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil \bar{\alpha_{max}^{jh}}\right)\right)
\end{equation*}. Claim follows.

\end{proof}

\subsection{FBLT vs. G-RMA/LCM}
\label{fblt vs grma lcm}

\begin{clm}\label{clm:fblt_lcm_rma}

Schedulability of FBLT is equal or better to G-RMA/LCM's when maximum
abort number of each preemptive transaction $s_{i}^{k}$ is less or equal to sum of maximum $m-1$ transactional lengths in all tasks subtracted from sum of total number
each higher priority transaction $s_{j}^{h}$ can directly conflict with $s_{i}^{k}$ times maximum $\alpha$ with which $s_{j}^{h}$ can conflict with maximum length transaction sharing objects with $s_{i}^{k}$ and $s_{j}^{h}$.

\end{clm}

\begin{proof}

By substituing $RC_{A}(T_{i})$ and $RC_{B}(T_{i})$ in (\ref{eq:utilization comparison})
with (\ref{eq:fblt_rc}) and (6.9) in \cite{shambake_phd_proposal}
respectively. 

\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_i^klen(s_{i}^{k})+\sum_{s_{iz}^{k}\in\chi_{i}^{k}}len(s_{iz}^{k})\right)+RC_{re}(T_{i})}{T_{i}}\label{eq:fblt_lcm_rma_comparison_1}\\
\le & \sum_{\forall\tau_{i}}\frac{\sum_{\forall\tau_{j}^{*}\in\gamma_{i}^{ex}}\sum_{\forall\theta\in\theta_{i}^{ex}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)\sum_{\forall\bar{s_{j}^{h}(\theta)}}len\left(\bar{s_{j}^{h}(\theta)}+\bar{\alpha_{max}^{jh}}s_{max}^{j}(\theta)\right)}{T_{i}}\nonumber \\
+ & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}}\left(1-\alpha_{max}^{ik}\right)len(s_{max}^{i})+RC_{re}(T_{i})}{T_{i}}\nonumber 
\end{eqnarray}
where $\tau_{j}^{*}=\left\{ \tau_{j}:\left(\tau_{j}\ne\tau_{i}\right)\wedge\left(p_{j}>p_{i}\right)\right\} $.
Let $\theta_{i}^{ex}=\theta_{i}+\theta_{i}^{*}$ where $\theta_{i}^{*}$
is the set of objects not accessed directly by $\tau_{i}$ but can
enforce transactions in $\tau_{i}$ to retry due to transitive retry.
Let $\gamma_{i}^{ex}=\gamma_{i}+\gamma_{i}^{*}$ where $\gamma_{i}^{*}$
is the set of tasks that access objects in $\theta_{i}^{*}$. $\bar{s_{j}^{h}}(\theta)$
can access multiple objects, so $s_{max}^{j}(\theta)$ is the maximum
length transaction conflicting with $\bar{s_{j}^{h}}(\theta)$. $\bar{s_{j}^{h}}(\theta)$ is included only once for all $\theta \in \Theta_j^h$. Each $\theta \in \theta_i^{ex}$ has its own $s_{max}^j(\theta)$. But $s_i^h$ can access multiple objects denoted as $\Theta_j^h$. So, $s_{max}^j(\theta)$ is replaced by $s_{max}^j(\Theta_j^h)$ where $s_{max}^j(\Theta_j^h)=max\{s_{max}^j(\theta),\forall \theta \in \Theta_j^h\}$. $s_{max}^j(\Theta_j^h)$ is included once for each $\theta \in \theta_i$. Each $\tau_i^x$ has the same interference pattern from higher priority jobs, $\tau_j^h$, under FBLT and G-RMA/LCM. Hence, $RC_{re}(T_i)$ for $\tau_i^x$ is the same under FBLT and G-RMA/LCM. Consequently,
(\ref{eq:fblt_lcm_rma_comparison_1}) will be 
\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_i^klen(s_{i}^{k})+\sum_{s_{iz}^{k}\in\chi_{i}^{k}}len(s_{iz}^{k})\right)}{T_{i}}\label{eq:fblt_lcm_rma_comparison_2}\\
\le & \sum_{\forall\tau_{i}}\frac{\sum_{\forall\tau_{j}^{*}\in\gamma_{i}^{ex}}\sum_
{\forall s_j^h(\Theta_j^h),\,\Theta_j^h\in\theta_{i}^{ex}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)len\left(\bar{s_{j}^{h}}(\Theta_j^h)+\bar{\alpha_{max}^{jh}}s_{max}^{j}(\Theta_j^h)\right)}{T_{i}}\nonumber \\
+ & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}}\left(1-\alpha_{max}^{ik}\right)len(s_{max}^{i})}{T_{i}}\nonumber 
\end{eqnarray}

Although different $s_{i}^{k}$ can have common conflicting transactions
$\bar{s_{j}^{h}}$, but no more than one $s_{i}^{k}$ can be preceded
by the same $\bar{s_{j}^{h}}$ in the $m\_$set. This happens because
transactions in the $m\_$set are non-preemptive. Original priority
of transactions preceding $s_{i}^{k}$ in the $m\_$set can be of
lower or higher priority than original priority of $s_{i}^{k}$. Under
G-RMA, $p_{j}>p_{i}$ means that $T_{j}\le T_{i}$, then $\left\lceil \frac{T_{i}}{T_{j}}\right\rceil \ge1$.
For each $s_{i}^{k}\in s_{i}$, there are a set of zero or more $\bar{s_{j}^{h}}(\Theta_j^h)\in\tau_{j}^{*}$
that are conflicting with $s_{i}^{k}$. Assuming this set of conflicting
transactions with $s_{i}^{k}$ is denoted as $\eta_{i}^{k}=\left\{ \bar{s_{j}^{h}}(\Theta_j^h)\in\tau_{j}^{*}:\left(\Theta_j^h\in\theta_{i}^{ex}\right)\wedge\left(\bar{s_{j}^{h}}(\Theta_j^h)\not\in\eta_{i}^{l},\, l\ne k\right)\right\} $.
The last condition $\bar{s_{j}^{h}}(\Theta_j^h)\not\in\eta_{i}^{l},\, l\ne k$
in definition of $\eta_{i}^{k}$ ensures that common transactions
$\bar{s_{j}^{h}}$ that can conflict with more than one transaction
$s_{i}^{k}\in\tau_{i}$ are split among different $\eta_{i}^{k},\, k=1,..,|s_{i}|$.
This condition is necessary because in G-RMA/LCM, no two or more transactions
of $\tau_{i}^{x}$ can be aborted by the same transaction of $\tau_{j}^{h}$
where $p_{j}^{h}>p_{i}^{x}$. By substitution of $\eta_{i}^{k}$ in
(\ref{eq:fblt_lcm_rma_comparison_2}), we get 
\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_i^klen(s_{i}^{k})+\sum_{s_{iz}^{k}\in\chi_{i}^{k}}len(s_{iz}^{k})\right)}{T_{i}}\label{eq:fblt_lcm_rma_comparison_4}\\
\le & \sum_{\forall\tau_{i}}\frac{\left(\sum_{\forall k=1}^{|s_{i}|}\sum_{\bar{s_{j}^{h}}(\Theta_j^h)\in\eta_{i}^{k}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)len\left(\bar{s_{j}^{h}}(\Theta_j^h)+\bar{\alpha_{max}^{jh}}s_{max}^{j}(\Theta_j^h)\right)\right)}{T_{i}}\nonumber \\
+ & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}}\left(1-\alpha_{max}^{ik}\right)len(s_{max}^{i})}{T_{i}}\nonumber 
\end{eqnarray}

$\bar{s_{j}^{h}}$ belongs to higher priority jobs than $\tau_{i}$. $s_{max}^{j}$ belongs to higher priority jobs than $\tau_{i}$ or $\tau_{i}$ itself. $s_{max}^{j}$ has a lower priority than $\tau_j$. Transactions in $m\_$set can belong to jobs
with original priority higher or lower than $\tau_{i}$. So, (\ref{eq:fblt_lcm_rma_comparison_4})
holds if for each $s_{i}^{k}\in\tau_{i}$ 
\begin{eqnarray}
\delta_i^klen(s_{i}^{k}) & \le & \left(\sum_{\bar{s_{j}^{h}}(\Theta_j^h)\in\eta_{i}^{k}}\left(\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)len\left(\bar{s_{j}^{h}}(\Theta_j^h)+\bar{\alpha_{max}^{jh}}s_{max}^{j}(\Theta_j^h)\right)\right)\right)\nonumber\\
 & + & \left(1-\alpha_{max}^{ik}\right)len(s_{max}^{i})-\sum_{s_{iz}^{k}\in\chi_{i}^{k}}len(s_{iz}^{k})
 \nonumber
\end{eqnarray}
Then
\begin{eqnarray}
\delta_i^k & \le & \left(\sum_{\bar{s_{j}^{h}}(\Theta_j^h)\in\eta_{i}^{k}}\left(\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)len\left(\frac{\bar{s_{j}^{h}}(\Theta_j^h)+\bar{\alpha_{max}^{jh}}s_{max}^{j}(\Theta_j^h)}{s_{i}^{k}}\right)\right)\right)\nonumber \\
 & + & \left(1-\alpha_{max}^{ik}\right)len\left(\frac{s_{max}^{i}}{s_{i}^{k}}\right)-\sum_{s_{iz}^{k}\in\chi_{i}^{k}}len\left(\frac{s_{iz}^{k}}{s_{i}^{k}}\right)\label{eq:fblt_lcm_rma_comparison_5}
\end{eqnarray}

Let $\epsilon=\left\{s_{u_{max}}:(1\le u \le n)\wedge \left(s_{u1_{max}} \ge s_{u2_{max}},\,u1 < u2 \right)\right\}$, where $n$ is number of tasks, and $s_{u_{max}}$ is maximum transactional length in any job of $\tau_u$. Thus, $\epsilon$ is the set of maximum transactional lengths of all task in non-increasing order. Each $s_{u_{max}} \in \epsilon$ belongs to a distinct task. Thus, $\sum_{s_{iz}^k \in \chi_i^k}len\left(\frac{s_{iz}^{k}}{s_{i}^{k}}\right)\le \sum_{u=1,\,s_{u_{max}}\in \epsilon}^{min(n,m)-1} s_{u_{max}}$. $\sum_{u=1,\,s_{u_{max}}\in \epsilon}^{min(n,m)-1} s_{u_{max}}$ is the sum of at most maximum $m-1$ transactional lengths of all tasks. $|\chi_i^k|\le m-1$ and $len(s_{max}^{j}(\Theta_j^h)) \ge len(s_{i}^{k})$. So, (\ref{eq:fblt_lcm_rma_comparison_5})
holds if 
\begin{equation}
\delta_i^k\le\left(\sum_{\bar{s_{j}^{h}}(\Theta_j^h)\in\eta_{i}^{k}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)\bar{\alpha_{max}^{jh}}\right)-\sum_{u=1,\,s_{u_{max}}\in \epsilon}^{min(n,m)-1} s_{u_{max}}\label{eq:fblt_lcm_rma_comparison_6}
\end{equation}

To bound effect of transitive retry, only objects that belong to $\theta_i$ (not whole $\theta_i^{ex}$) will be considered. So, G-RMA/LCM acts as if there were no transitive retry. Thus, $\eta_i^k$ is modified to $\bar{\eta_i^k}=\left\{ \bar{s_{j}^{h}}(\Theta)\in\tau_{j}^{*}:\left(\Theta \in \Theta_j^h \cap \theta_{i}\right)\wedge\left(\bar{s_{j}^{h}}(\Theta)\not\in\eta_{i}^{l},\, l\ne k\right)\right\}$. As $\bar{\eta_i^k} \subseteq \eta_i^k$, then (\ref{eq:fblt_lcm_rma_comparison_6}) still holds if $\eta_i^k$ is replaced with $\bar{\eta_i^k}$.  Consequently, (\ref{eq:fblt_lcm_rma_comparison_6}) holds if 
%starthere
\begin{equation}
\delta_i^k\le\left(\sum_{\bar{s_{j}^{h}}(\Theta)\in \bar{\eta_{i}^{k}}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)\bar{\alpha_{max}^{jh}}\right)-\sum_{u=1,\,s_{u_{max}}\in \epsilon}^{min(n,m)-1} s_{u_{max}}\label{eq:fblt_lcm_rma_comparison_7}
\end{equation}

$\left(\sum_{\bar{s_{j}^{h}}(\Theta) \in \bar{\eta_{i}^{k}}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)\bar{\alpha_{max}^{jh}}\right)$ is the sum of total number each transaction $s_j^h$ can directly conflict with $s_i^k$ multiplied by maximum $\alpha$ with which $s_j^h$ can conflict with maximum length transaction sharing objects with $s_i^k$ and $s_j^h$. Claim follows.

\end{proof}

\subsection{FBLT vs. PNF}
\label{sec:fblt vs pnf}

\begin{clm}\label{clm:fblt_pnf_edf}

Let $\rho_{i}^{j}(k)$ be the difference between sum of transactional
lengths of all transactions in $\tau_{j}$ conflicting with $s_{i}^{k}$,
and the maximum length transaction in $\tau_{i}$. Schedulability
of FBLT is better or equal to PNF's if maximum abort number of any
preemptive transaction $s_{i}^{k}$ is not greater than sum of maximum
$m-1$ transactional lengths in all tasks subtracted from sum of all
$\rho_{i}^{j}(k)$ of all jobs of $\tau_{j}$ interfering with $\tau_{i}$.

\end{clm}

\begin{proof}

By substituting $RC_{A}(T_{i})$ and $RC_{B}(T_{i})$ in (\ref{eq:utilization comparison})
with (\ref{eq:fblt_rc}) and (6.1) in \cite{shambake_phd_proposal}
respectively. 

\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_{i}^{k}len(s_{i}^{k})+\sum_{s_{iz}^{k}\in\chi_{i}^{k}}len(s_{iz}^{k})\right)+RC_{re}(T_{i})}{T_{i}}\label{eq:fblt_pnf_comparison_1}\\
\le & \sum_{\forall\tau_{i}}\frac{\sum_{\forall\tau_{j}\in\gamma_{i}}\sum_{\theta\in\theta_{i}}\left(\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)\sum_{\forall\bar{s_{j}^{h}}(\theta)}len\left(\bar{s_{j}^{h}}(\theta)\right)\right)}{T_{i}}\nonumber 
\end{eqnarray}


$\bar{s_{j}^{h}}(\theta)$ can access multiple objects. $\bar{s_{j}^{h}}(\theta)$
is included only once for all objects accessed by it. $RC_{re}(T_{i})$
is given by (6.8) in \cite{shambake_phd_proposal} in case of G-EDF,
and (6.10) in \cite{shambake_phd_proposal} in case of G-RMA. Substituting
$RC_{re}(T_{i})=\sum_{\forall\tau_{j}\in\gamma_{i}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)s_{i_{max}}$,
covers $RC_{re}(T_{i})$ given by (6.8) and (6.10) in \cite{shambake_phd_proposal}
and maintains correctness of (\ref{eq:fblt_pnf_comparison_1}). If
$\tau_{j}$ has no shared objects with $\tau_{i}$, then release of
any higher priority job $\tau_{j}^{y}$ will not abort any transaction
in any job of $\tau_{i}$. So, (\ref{eq:fblt_pnf_comparison_1}) holds
if 

\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_{i}^{k}len(s_{i}^{k})+\sum_{s_{iz}^{k}\in\chi_{i}^{k}}len(s_{iz}^{k})\right)}{T_{i}}\label{eq:fblt_pnf_comparison_1-1}\\
\le & \sum_{\forall\tau_{i}}\frac{\sum_{\forall\tau_{j}\in\gamma_{i}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)\left(\left(\sum_{\forall\bar{s_{j}^{h}}(\Theta),\,\Theta\in\theta_{i}}len\left(\bar{s_{j}^{h}}(\theta)\right)\right)-s_{i_{max}}\right)}{T_{i}}\nonumber 
\end{eqnarray}
For each $s_{i}^{k}\in s_{i}$, there are a set of zero or more $\bar{s_{j}^{h}}(\Theta)\in\tau_{j},\,\forall\tau_{j}\ne\tau_{i}$
that are conflicting with $s_{i}^{k}$. Assuming this set of conflicting
transactions with $s_{i}^{k}$ is denoted as $\eta_{i}^{k}(j)=\left\{ \bar{s_{j}^{h}}(\Theta)\in\tau_{j}:\left(\Theta\in\theta_{i}\right)\wedge\left(\tau_{j}\ne\tau_{i}\right)\wedge\left(\bar{s_{j}^{h}}(\Theta)\not\in\eta_{i}^{l},\, l\ne k\right)\right\} $.
The last condition $\bar{s_{j}^{h}}(\Theta)\not\in\eta_{i}^{l},\, l\ne k$
in definition of $\eta_{i}^{k}$ ensures that common transactions
$\bar{s_{j}^{h}}$ that can conflict with more than one transaction
$s_{i}^{k}\in\tau_{i}$ are split among different $\eta_{i}^{k}(j),\, k=1,..,|s_{i}|$.
This condition is necessary because in PNF, no two or more transactions
of $\tau_{i}^{x}$ can be aborted by the same transaction of $\tau_{j}^{h}$.
Let $\gamma_{i}^{k}$ be subset of $\gamma_{i}$ that contains tasks
with transactions conflicting directly with $s_{i}^{k}$. By substitution
of $\eta_{i}^{k}(j)$ and $\gamma_{i}^{k}$ in (\ref{eq:fblt_pnf_comparison_1-1}),
(\ref{eq:fblt_pnf_comparison_1-1}) holds if for each $s_{i}^{k}$:
\begin{eqnarray}
 & \delta_{i}^{k}+\sum_{s_{iz}^{k}\in\chi_{i}^{k}}len(\frac{s_{iz}^{k}}{s_{i}^{k}})\label{eq:fblt_pnf_comparison_1-1-1}\\
\le & \sum_{\forall\tau_{j}\in\gamma_{i}^{k}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)\left(\left(\sum_{\forall\bar{s_{j}^{h}}(\Theta)\in\eta_{i}^{k}(j)}len\left(\frac{\bar{s_{j}^{h}}(\Theta)}{s_{i}^{k}}\right)\right)-len\left(\frac{s_{i_{max}}}{s_{i}^{k}}\right)\right)\nonumber 
\end{eqnarray}
Non-preemptive transactions preceding $s_{i}^{k}$ in $m\_$set can
have direct or indirect conflict with $s_{i}^{k}$. Under PNF, transactions
can only have direct conflict with $s_{i}^{k}$. So, $s_{iz}^{k}$
on the left hand side of (\ref{eq:fblt_pnf_comparison_1-1-1}) is
not necessarily included in $\bar{s_{j}^{h}}(\Theta)$ on the right
hand side of (\ref{eq:fblt_pnf_comparison_1-1-1}). Let $\epsilon=\left\{ s_{u_{max}}:(1\le u\le n)\wedge\left(s_{u1_{max}}\ge s_{u2_{max}},\, u1<u2\right)\right\} $,
where $n$ is number of tasks, and $s_{u_{max}}$ is maximum transactional
length in any job of $\tau_{u}$. Thus, $\epsilon$ is the set of
maximum transactional lengths of all task in non-increasing order.
Each $s_{u_{max}}\in\epsilon$ belongs to a distinct task. Thus, $\sum_{s_{iz}^{k}\in\chi_{i}^{k}}len\left(\frac{s_{iz}^{k}}{s_{i}^{k}}\right)\le\sum_{u=1,\, s_{u_{max}}\in\epsilon}^{min(n,m)-1}s_{u_{max}}$.
$\sum_{u=1,\, s_{u_{max}}\in\epsilon}^{min(n,m)-1}s_{u_{max}}$ is
the sum of at most maximum $m-1$ transactional lengths of all tasks.
$|\chi_{i}^{k}|\le m-1$. Then (\ref{eq:fblt_pnf_comparison_1-1-1})
holds if 
\begin{eqnarray*}
\delta_{i}^{k} & \le & \left(\sum_{\forall\tau_{j}\in\gamma_{i}^{k}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)len\left(\frac{\left(\sum_{\forall\bar{s_{j}^{h}}(\Theta)\in\eta_{i}^{k}(j)}len\left(\bar{s_{j}^{h}}(\Theta)\right)\right)-s_{i_{max}}}{s_{i}^{k}}\right)\right)\\
& - & \sum_{u=1,\, s_{u_{max}}\in\epsilon}^{min(n,m)-1}s_{u_{max}}\label{eq:fblt_pnf_comparison_1-1-1-1}
\end{eqnarray*}
As $\rho_{i}^{j}(k)=\left(\sum_{\forall\bar{s_{j}^{h}}(\Theta)\in\eta_{i}^{k}(j)}len\left(\bar{s_{j}^{h}}(\Theta)\right)\right)-s_{i_{max}},\,\tau_{j}\in\gamma_{i}^{k}$,
and $\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)$
is total number of jobs of $\tau_{j}$ interfering with $\tau_{i}$,
Claim follows.

\end{proof}

\subsection{FBLT vs. Lock-free}
\label{sec:fblt vs lock free}

\begin{clm}\label{clm:fblt_edf_lock-free}

Under G-EDF and G-RMA, schedulability of FBLT is equal or better than
lock-free's if $s_{max}\le r_{max}$. If transactions execute in FIFO
order (i. e., $\delta_{i}^{k}=0,\,\forall s_{i}^{k}$) and contention
is high, $s_{max}$ can be much larger than $r_{max}$.

\end{clm}

\begin{proof}

Lock-free synchronization \cite{key-5,stmconcurrencycontrol:emsoft11}
accesses only one object. Thus, the number of accessed objects per
transaction in FBLT is limited to one. This allows us to compare the
schedulability of FBLT with the lock-free algorithm.

By substituting $RC_{A}(T_{i})$ and $RC_{B}(T_{i})$ in (\ref{eq:utilization comparison})
with (\ref{eq:fblt_rc}) and (6.17) in \cite{shambake_phd_proposal}
respectively. 

\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_{i}^{k}len(s_{i}^{k})+\sum_{s_{iz}^{k}\in\chi_{i}^{k}}len(s_{iz}^{k})\right)+RC_{re}(T_{i})}{T_{i}}\label{eq:fblt_lf_comparison_1}\\
\le & \sum_{\forall\tau_{i}}\frac{\left(\sum_{\forall\tau_{j}\in\gamma_{i}}\left(\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)\beta_{i,j}r_{max}\right)\right)+RC_{re}(T_{i})}{T_{i}}\nonumber 
\end{eqnarray}
where $\beta_{i,j}$ is the number of retry loops of $\tau_{j}$ that
access the same objects as accessed by any retry loop of $\tau_{i}$
\cite{key-5}. $r_{max}$ is the maximum execution cost of a single
iteration of any retry loop of any task \cite{key-5}. For G-EDF(G-RMA),
any job $\tau_{i}^{x}$ under FBLT has the same pattern of interference
from higher priority jobs as ECM(RCM) respectively. $RC_{re}(T_{i})$
for ECM, RCM and lock-free are given by Claims 25, 26 and 27 in \cite{shambake_phd_proposal}
respectively.$\therefore$ $RC_{re}(T_{i})=\left\lceil \frac{T_{i}}{T_{j}}\right\rceil s_{i_{max}},\,\forall\tau_{j}\neq\tau_{i}$
covers $RC_{re}(T_{i})$ for G-EDF/FBLT and G-RMA/FBLT. $RC_{re}(T_{i})=\left\lceil \frac{T_{i}}{T_{j}}\right\rceil r_{i_{max}},\,\forall\tau_{j}\neq\tau_{i}$
covers retry cost for G-EDF/lock-free and G-RMA/lock-free. $\therefore$
(\ref{eq:fblt_lf_comparison_1}) becomes 
\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_{i}^{k}len(s_{i}^{k})+\sum_{s_{iz}^{k}\in\chi_{i}^{k}}len(s_{iz}^{k})\right)+\sum_{\forall\tau_{j}\neq\tau_{i}}\left\lceil \frac{T_{i}}{T_{j}}\right\rceil s_{i_{max}}}{T_{i}}\label{eq:fblt_lf_comparison_8}\\
\le & \sum_{\forall\tau_{i}}\frac{\left(\sum_{\forall\tau_{j}\in\gamma_{i}}\left(\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)\beta_{i,j}r_{max}\right)\right)+\sum_{\forall\tau_{j}\neq\gamma_{i}}\left\lceil \frac{T_{i}}{T_{j}}\right\rceil r_{i_{max}}}{T_{i}}\nonumber 
\end{eqnarray}
Since $s_{max}\ge s_{i_{max}},\, len(s_{i}^{k}),\, len(s_{iz}^{k}),\,\forall i,z,k$
and $r_{max}\ge r_{i_{max}}$ $\therefore$ (\ref{eq:fblt_lf_comparison_8})
holds if 
\begin{eqnarray}
 & \sum_{\forall\tau_{i}}\frac{\left(\left(\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_{i}^{k}+|\chi_{i}^{k}|\right)\right)+\sum_{\forall\tau_{j}\neq\tau_{i}}\left\lceil \frac{T_{i}}{T_{j}}\right\rceil \right)s_{max}}{T_{i}}\label{eq:fblt_lf_comparison_6}\\
\le & \sum_{\forall\tau_{i}}\frac{\left(\left(\sum_{\forall\tau_{j}\in\gamma_{i}}\left(\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)\beta_{i,j}\right)\right)+\sum_{\forall\tau_{j}\neq\tau_{i}}\left\lceil \frac{T_{i}}{T_{j}}\right\rceil \right)r_{max}}{T_{i}}\nonumber 
\end{eqnarray}
$\therefore$ (\ref{eq:fblt_lf_comparison_6}) holds if for each $\tau_{i}$
\begin{eqnarray}
 & \left(\left(\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_{i}^{k}+|\chi_{i}^{k}|\right)\right)+\sum_{\forall\tau_{j}\neq\tau_{i}}\left\lceil \frac{T_{i}}{T_{j}}\right\rceil \right)s_{max}\label{eq:fblt_lf_comparison_7}\\
\le & \left(\left(\sum_{\forall\tau_{j}\in\gamma_{i}}\left(\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)\beta_{i,j}\right)\right)+\sum_{\forall\tau_{j}\neq\tau_{i}}\left\lceil \frac{T_{i}}{T_{j}}\right\rceil \right)r_{max}\nonumber 
\end{eqnarray}
$\therefore$
\begin{eqnarray}
\frac{s_{max}}{r_{max}} & \le & \frac{\left(\sum_{\forall\tau_{j}\in\gamma_{i}}\left(\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)\beta_{i,j}\right)\right)+\sum_{\forall\tau_{j}\neq\tau_{i}}\left\lceil \frac{T_{i}}{T_{j}}\right\rceil }{\left(\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_{i}^{k}+|\chi_{i}^{k}|\right)\right)+\sum_{\forall\tau_{j}\neq\tau_{i}}\left\lceil \frac{T_{i}}{T_{j}}\right\rceil }\label{eq:fblt_lf_comparison_9}
\end{eqnarray}
It appears from (\ref{eq:fblt_lf_comparison_9}) that as $\delta_{i}^{k}$,
as well as $|\chi_{i}^{k}|$, increases, then $s_{max}/r_{max}$ decreases.
So, to get the lower bound on $s_{max}/r_{max}$, let $\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_{i}^{k}+|\chi_{i}^{k}|\right)$
reaches its maximum value. This maximum value is the total number
of interfering transactions belonging to any job $\tau_{j}^{l},\, j\ne i$.
Priority of $\tau_{j}^{l}$ can be higher or lower than current instance
of $\tau_{i}$. Beyond this maximum value, there will be no more transactions
to conflict with $s_{i}^{k}$. So, higher values for any $\delta_{i}^{k}$
beyond maximum value will be ineffective. $\therefore\,\sum_{\forall s_{i}^{k}\in s_{i}}\left(\delta_{i}^{k}+|\chi_{i}^{k}|\right)\le\sum_{\forall\tau_{j}\in\gamma_{i}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)$.
Consequently, (\ref{eq:fblt_lf_comparison_9}) will be 
\begin{eqnarray}
\frac{s_{max}}{r_{max}} & \le & \frac{\left(\sum_{\forall\tau_{j}\in\gamma_{i}}\left(\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)\beta_{i,j}\right)\right)+\sum_{\forall\tau_{j}\neq\tau_{i}}\left\lceil \frac{T_{i}}{T_{j}}\right\rceil }{\left(\sum_{\forall\tau_{j}\in\gamma_{i}}\left(\left\lceil \frac{T_{i}}{T_{j}}\right\rceil +1\right)\right)+\sum_{\forall\tau_{j}\neq\tau_{i}}\left\lceil \frac{T_{i}}{T_{j}}\right\rceil }\label{eq:fblt_lf_comparison_10}
\end{eqnarray}
As we look for the lower bound on $\frac{s_{max}}{r_{max}}$, let
$\beta_{i,j}$ assumes its minimum value. So, $\beta_{i,j}=1$. $\therefore$
(\ref{eq:fblt_lf_comparison_10}) holds if $\frac{s_{max}}{r_{max}}\le1$.

Let $\delta_{i}^{k}(T_{i})\rightarrow0$ in (\ref{eq:fblt_lf_comparison_9}).
This means transactions approximately execute in their arrival order.
Let $\beta_{i,j}\rightarrow\infty,\,\left\lceil \frac{T_{i}}{T_{j}}\right\rceil \rightarrow\infty$
in (\ref{eq:fblt_lf_comparison_9}) . This means contention is high.
Consequently, $\frac{s_{max}}{r_{max}}\rightarrow\infty$. So, if
transactions execute in FIFO order and contention is high, $s_{max}$
can be much larger than $r_{max}$. Claim follows.

\end{proof}

\section{Experimental Evaluation}\label{exp_eval}

%Having established PNF's retry and response time bounds, and the conditions under which it outperforms ECM, RCM, LCM, and lock-free synchronization, 
We now would like to understand how PNF's retry cost compares with competitors in practice (i.e., on average). Since this can only be understood experimentally, we implement PNF and the competitors and conduct experiments. 

%\subsection{Experimental Setup}

We used the ChronOS real-time Linux kernel~\cite{dellinger2011chronos}
and the RSTM library~\cite{marathe2006lowering} in our implementation. We implemented G-EDF and G-RMA schedulers in ChronOS, and modified RSTM to include implementations of ECM, RCM, LCM, and PNF. For the retry-loop lock-free synchronization, we used a loop that reads an object and attempts to write to it  using a CAS  instruction. The task retries until the CAS succeeds. We used an 8 core, 2GHz AMD Opteron platform. The average time taken for one write operation by RSTM on any core is 0.0129653375$\mu s$, and the average time taken by one CAS-loop operation on any core is 0.0292546250 $\mu s$.

We used four task sets consisting of 4, 5, 8, and 20 periodic tasks. Each task runs in its own thread and has a set of atomic sections. Atomic section properties are probabilistically controlled using three parameters: the maximum and minimum lengths of any atomic section within a task, and the total length of atomic sections within any task. Since lock-free synchronization cannot handle more than one object per atomic section, we first compare PNF's retry cost with that of lock-free (and other CMs) for one object per transaction. We then compare PNF's retry cost with that of other CMs for multiple objects per transaction.


\begin{figure}
\centering
\subfigure[ECM, RCM, LCM, PNF, Lock-Free]{
\includegraphics[scale=0.6]
{figures/Abr_dur_5t_1obj_1wr}
\label{fig:pnf_results_1_obj_all}
}
%~
\subfigure[ECM, RCM, LCM, PNF]{
\includegraphics[scale=0.6]
{figures/Abr_dur_5t_1obj_1wr_without_lf}
\label{fig:pnf_results_1_obj_without_lock_free}
}
\caption{Avg. retry cost (one object/transaction).}
\label{fig:pnf_results_uniobject}
\end{figure}

Figures~\ref{fig:pnf_results_uniobject} and~\ref{fig-RC-pnf-4t} show the average retry cost for the 5 task and 4 task case, respectively, under 1 and 5 shared objects, respectively. 
On the x-axis of the figures, we record 3 parameters $x$, $y$, and $z$. $x$ is the ratio of the total length of all atomic sections of a task to the task WCET. $y$ is the ratio of the maximum length of any atomic section of a task to the task WCET. $z$ is the ratio of the minimum length of any atomic section of a task to the task WCET. Confidence level of all data points is 0.95.
 
While Figure~\ref{fig:pnf_results_1_obj_all} includes all methods, Figure~\ref{fig:pnf_results_1_obj_without_lock_free} excludes lock-free. From these figures, we observe that lock-free has the largest retry cost, as it provides no conflict resolution. LCM is better than the others. PNF's retry cost closely approximates ECM's and RCMs, as there is no transitive retry. From Figure~\ref{fig-RC-pnf-4t}, we observe that PNF has shorter or comparable retry cost than ECM, RCM, and LCM.

 Similar trends were observed for the other task sets.
 %; those are omitted here for brevity and due to space limitations. 


\begin{comment}
In Figure~\ref{fig-RC-pnf-20t}, retry costs are close. This happens because each task's execution time is small relative to the task's period. Consequently, atomic sections have small length and are highly unlikely to be triggered at the same time. Thus, contention, as well as, retry costs are low.
\end{comment}


\begin{figure}
\centering
\includegraphics[scale=0.6]{figures/Abr_dur_4t_5obj_1wr}
\caption{Avg. retry cost (5 shared objects, 4 tasks).}
\label{fig-RC-pnf-4t}
\end{figure}

\begin{comment}
\begin{figure}
\centering
\subfigure[Task set 1 (4 tasks)]{
\includegraphics[scale=0.6]
{figures/Abr_dur_4t_5obj_1wr}
\label{fig-RC-pnf-4t}
}
~
\subfigure[Task set 2 (8 tasks)]{
\includegraphics[scale=0.6]
{figures/Abr_dur_8t_9obj_1wr}
\label{fig-RC-pnf-8t}
}
~
\subfigure[Task set 3 (20 tasks)]{
\includegraphics[scale=0.5]{figures/Abr_dur_20t_21obj_1wr}
\label{fig-RC-pnf-20t}
}
\caption{Average retry cost under multiple objects per transaction.}
\label{fig:pnf_results_multiobject}
\end{figure}
\end{comment}


\section{Conclusions}\label{conclusion}

Transitive retry increases transactional retry cost under ECM, RCM, and LCM. PNF avoids transitive retry by avoiding   transactional preemptions. PNF reduces the priority of aborted transactions to enable other tasks to execute, increasing processor usage. Executing transactions are not preempted due to the release of higher priority jobs. On the negative side of PNF, higher priority jobs can be blocked by executing transactions of lower priority jobs. 

EDF/PNF's schedulability is equal or better than ECM's when atomic section lengths are almost equal. RMA/PNF's schedulability is equal or better than RCM's when lower priority jobs suffer greater conflicts from higher priority ones. Similar conditions hold for the schedulability comparison between PNF and LCM, in addition to the increase of $\alpha$ terms to 1. This is logical as LCM with G-EDF (G-RMA) defaults to ECM (RCM) with $\alpha\rightarrow 1$. For PNF's schedulability to be equal or better than lock-free, the upper bound on $s_{max}/r_{max}$ must be 1, instead of 0.5 under ECM and RCM. 


% Bibliography
\bibliographystyle{acmsmall}
\bibliography{/e/lectures/real-time/PhD-work/STM/writing/global_bibliography/global_bibliography}

% History dates
\received{February 2007}{March 2009}{June 2009}

% Electronic Appendix
%\elecappendix

\medskip


\end{document}

